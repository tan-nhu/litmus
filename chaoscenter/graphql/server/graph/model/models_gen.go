// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Audit interface {
	IsAudit()
}

// Defines the common probe properties shared across different ProbeTypes
type CommonProbeProperties interface {
	IsCommonProbeProperties()
}

type ResourceDetails interface {
	IsResourceDetails()
}

type ActionPayload struct {
	RequestID    string  `json:"requestID"`
	RequestType  string  `json:"requestType"`
	K8sManifest  string  `json:"k8sManifest"`
	Namespace    string  `json:"namespace"`
	ExternalData *string `json:"externalData"`
	Username     *string `json:"username"`
}

type Annotation struct {
	Categories       string `json:"categories"`
	Vendor           string `json:"vendor"`
	CreatedAt        string `json:"createdAt"`
	Repository       string `json:"repository"`
	Support          string `json:"support"`
	ChartDescription string `json:"chartDescription"`
}

// Defines the input for CMD probe properties
type CMDProbeRequest struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// Command of the Probe
	Command string `json:"command"`
	// Comparator of the Probe
	Comparator *ComparatorInput `json:"comparator"`
	// Source of the Probe
	Source *string `json:"source"`
}

// Defines the details for a chaos experiment
type ChaosExperimentRequest struct {
	// ID of the experiment
	ExperimentID *string `json:"experimentID"`
	// Boolean check indicating if the created scenario will be executed or not
	RunExperiment *bool `json:"runExperiment"`
	// Manifest of the experiment
	ExperimentManifest string `json:"experimentManifest"`
	// Type of the experiment
	ExperimentType *ExperimentType `json:"experimentType"`
	// Cron syntax of the experiment schedule
	CronSyntax string `json:"cronSyntax"`
	// Name of the experiment
	ExperimentName string `json:"experimentName"`
	// Description of the experiment
	ExperimentDescription string `json:"experimentDescription"`
	// Array containing weightage and name of each chaos experiment in the experiment
	Weightages []*WeightagesInput `json:"weightages"`
	// Bool value indicating whether the experiment is a custom experiment or not
	IsCustomExperiment bool `json:"isCustomExperiment"`
	// ID of the target infra in which the experiment will run
	InfraID string `json:"infraID"`
	// Tags of the infra
	Tags []string `json:"tags"`
}

// Defines the response received for querying the details of chaos experiment
type ChaosExperimentResponse struct {
	// ID of the experiment
	ExperimentID string `json:"experimentID"`
	ProjectID    string `json:"projectID"`
	// Cron syntax of the experiment schedule
	CronSyntax string `json:"cronSyntax"`
	// Name of the experiment
	ExperimentName string `json:"experimentName"`
	// Description of the experiment
	ExperimentDescription string `json:"experimentDescription"`
	// Bool value indicating whether the experiment is a custom experiment or not
	IsCustomExperiment bool `json:"isCustomExperiment"`
	// Tags of the infra
	Tags []string `json:"tags"`
}

type ChaosHub struct {
	// ID of the chaos hub
	ID string `json:"id"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// ID of the project in which the chaos hub is present
	ProjectID string `json:"projectID"`
	// Default Hub Identifier
	IsDefault bool `json:"isDefault"`
	// Name of the chaos hub
	Name string `json:"name"`
	// Tags of the ChaosHub
	Tags []string `json:"tags"`
	// User who created the ChaosHub
	CreatedBy *UserDetails `json:"createdBy"`
	// User who has updated the ChaosHub
	UpdatedBy *UserDetails `json:"updatedBy"`
	// Description of ChaosHub
	Description *string `json:"description"`
	// Type of ChaosHub
	HubType HubType `json:"hubType"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key for authenticating into private chaos hub
	SSHPrivateKey *string `json:"sshPrivateKey"`
	// Bool value indicating if the chaos hub is removed
	IsRemoved bool `json:"isRemoved"`
	// Timestamp when the chaos hub was created
	CreatedAt string `json:"createdAt"`
	// Timestamp when the chaos hub was last updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp when the chaos hub was last synced
	LastSyncedAt string `json:"lastSyncedAt"`
}

func (ChaosHub) IsResourceDetails() {}
func (ChaosHub) IsAudit()           {}

// Defines filter options for ChaosHub
type ChaosHubFilterInput struct {
	// Name of the ChaosHub
	ChaosHubName *string `json:"chaosHubName"`
	// Tags of a chaos hub
	Tags []string `json:"tags"`
	// Description of a chaos hub
	Description *string `json:"description"`
}

type ChaosHubStatus struct {
	// ID of the hub
	ID string `json:"id"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// Bool value indicating whether the hub is available or not.
	IsAvailable bool `json:"isAvailable"`
	// Total number of experiments in the hub
	TotalFaults string `json:"totalFaults"`
	// Total experiments
	TotalExperiments string `json:"totalExperiments"`
	// Name of the chaos hub
	Name string `json:"name"`
	// Type of ChaosHub
	HubType HubType `json:"hubType"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Bool value indicating whether the hub is private or not.
	IsRemoved bool `json:"isRemoved"`
	// Private SSH key for authenticating into private chaos hub
	SSHPrivateKey *string `json:"sshPrivateKey"`
	// Public SSH key for authenticating into private chaos hub
	SSHPublicKey *string `json:"sshPublicKey"`
	// Timestamp when the chaos hub was last synced
	LastSyncedAt string `json:"lastSyncedAt"`
	// Tags of the ChaosHub
	Tags []string `json:"tags"`
	// User who created the ChaosHub
	CreatedBy *UserDetails `json:"createdBy"`
	// User who has updated the ChaosHub
	UpdatedBy *UserDetails `json:"updatedBy"`
	// Created at timestamp
	CreatedAt string `json:"createdAt"`
	// Updated at timestamp
	UpdatedAt string `json:"updatedAt"`
	// Description of ChaosHub
	Description *string `json:"description"`
	// Default Hub Identifier
	IsDefault bool `json:"isDefault"`
}

func (ChaosHubStatus) IsResourceDetails() {}
func (ChaosHubStatus) IsAudit()           {}

type Chart struct {
	APIVersion  string              `json:"apiVersion"`
	Kind        string              `json:"kind"`
	Metadata    *Metadata           `json:"metadata"`
	Spec        *Spec               `json:"spec"`
	PackageInfo *PackageInformation `json:"packageInfo"`
}

type CloningInput struct {
	// Name of the chaos hub
	Name string `json:"name"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password      *string `json:"password"`
	SSHPrivateKey *string `json:"sshPrivateKey"`
	IsDefault     bool    `json:"isDefault"`
}

// Defines the properties of the comparator
type Comparator struct {
	// Type of the Comparator
	Type string `json:"type"`
	// Value of the Comparator
	Value string `json:"value"`
	// Operator of the Comparator
	Criteria string `json:"criteria"`
}

// Defines the input properties of the comparator
type ComparatorInput struct {
	// Type of the Comparator
	Type string `json:"type"`
	// Value of the Comparator
	Value string `json:"value"`
	// Operator of the Comparator
	Criteria string `json:"criteria"`
}

type ConfirmInfraRegistrationResponse struct {
	IsInfraConfirmed bool    `json:"isInfraConfirmed"`
	NewAccessKey     *string `json:"newAccessKey"`
	InfraID          *string `json:"infraID"`
}

// Defines the details required for creating a chaos hub
type CreateChaosHubRequest struct {
	// Name of the chaos hub
	Name string `json:"name"`
	// Tags of the ChaosHub
	Tags []string `json:"tags"`
	// Description of ChaosHub
	Description *string `json:"description"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key for authenticating into private chaos hub
	SSHPrivateKey *string `json:"sshPrivateKey"`
	// Public SSH key for authenticating into private chaos hub
	SSHPublicKey *string `json:"sshPublicKey"`
}

type CreateEnvironmentRequest struct {
	EnvironmentID string          `json:"environmentID"`
	Name          string          `json:"name"`
	Type          EnvironmentType `json:"type"`
	Description   *string         `json:"description"`
	Tags          []string        `json:"tags"`
}

type CreateRemoteChaosHub struct {
	// Name of the chaos hub
	Name string `json:"name"`
	// Tags of the ChaosHub
	Tags []string `json:"tags"`
	// Description of ChaosHub
	Description *string `json:"description"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
}

// Defines the start date and end date for the filtering the data
type DateRange struct {
	// Start date
	StartDate string `json:"startDate"`
	// End date
	EndDate *string `json:"endDate"`
}

type Environment struct {
	ProjectID     string          `json:"projectID"`
	EnvironmentID string          `json:"environmentID"`
	Name          string          `json:"name"`
	Description   *string         `json:"description"`
	Tags          []string        `json:"tags"`
	Type          EnvironmentType `json:"type"`
	CreatedAt     string          `json:"createdAt"`
	CreatedBy     *UserDetails    `json:"createdBy"`
	UpdatedBy     *UserDetails    `json:"updatedBy"`
	UpdatedAt     string          `json:"updatedAt"`
	IsRemoved     *bool           `json:"isRemoved"`
	InfraIDs      []string        `json:"infraIDs"`
}

func (Environment) IsResourceDetails() {}
func (Environment) IsAudit()           {}

// Defines filter options for infras
type EnvironmentFilterInput struct {
	// Name of the environment
	Name *string `json:"name"`
	// ID of the environment
	Description *string `json:"description"`
	// Type name of environment
	Type *string `json:"type"`
	// Tags of an environment
	Tags []*EnvironmentType `json:"tags"`
}

// Defines sorting options for experiment
type EnvironmentSortInput struct {
	// Field in which sorting will be done
	Field EnvironmentSortingField `json:"field"`
	// Bool value indicating whether the sorting will be done in ascending order
	Ascending *bool `json:"ascending"`
}

// Defines the Executed by which experiment details for Probes
type ExecutedByExperiment struct {
	// Experiment ID
	ExperimentID string `json:"experimentID"`
	// Experiment Name
	ExperimentName string `json:"experimentName"`
	// Timestamp at which the experiment was last updated
	UpdatedAt int `json:"updatedAt"`
	// User who has updated the experiment
	UpdatedBy *UserDetails `json:"updatedBy"`
}

// Defines the Execution History of experiment referenced by the Probe
type ExecutionHistory struct {
	// Probe Mode
	Mode Mode `json:"mode"`
	// Fault Name
	FaultName string `json:"faultName"`
	// Fault Status
	Status *Status `json:"status"`
	// Fault executed by which experiment
	ExecutedByExperiment *ExecutedByExperiment `json:"executedByExperiment"`
}

// Defines the details for a experiment
type Experiment struct {
	ProjectID string `json:"projectID"`
	// ID of the experiment
	ExperimentID string `json:"experimentID"`
	// Type of the experiment
	ExperimentType *string `json:"experimentType"`
	// Manifest of the experiment
	ExperimentManifest string `json:"experimentManifest"`
	// Cron syntax of the experiment schedule
	CronSyntax string `json:"cronSyntax"`
	// Name of the experiment
	Name string `json:"name"`
	// Description of the experiment
	Description string `json:"description"`
	// Array containing weightage and name of each chaos fault in the experiment
	Weightages []*Weightages `json:"weightages"`
	// Bool value indicating whether the experiment is a custom experiment or not
	IsCustomExperiment bool `json:"isCustomExperiment"`
	// Timestamp when the experiment was last updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp when the experiment was created
	CreatedAt string `json:"createdAt"`
	// Target infra in which the experiment will run
	Infra *Infra `json:"infra"`
	// Bool value indicating if the experiment has removed
	IsRemoved bool `json:"isRemoved"`
	// Tags of the experiment
	Tags []string `json:"tags"`
	// User who created the experiment
	CreatedBy *UserDetails `json:"createdBy"`
	// Array of object containing details of recent experiment runs
	RecentExperimentRunDetails []*RecentExperimentRun `json:"recentExperimentRunDetails"`
	// Details of the user who updated the experiment
	UpdatedBy *UserDetails `json:"updatedBy"`
}

func (Experiment) IsResourceDetails() {}
func (Experiment) IsAudit()           {}

type ExperimentDetails struct {
	// Engine Manifest
	EngineDetails string `json:"engineDetails"`
	// Experiment Manifest
	ExperimentDetails string `json:"experimentDetails"`
}

// Defines filter options for experiments
type ExperimentFilterInput struct {
	// Name of the experiment
	ExperimentName *string `json:"experimentName"`
	// Name of the infra in which the experiment is running
	InfraName *string `json:"infraName"`
	// ID of the infra in which the experiment is running
	InfraID *string `json:"infraID"`
	// Bool value indicating if Chaos Infrastructure is active
	InfraActive *bool `json:"infraActive"`
	// Scenario type of the experiment i.e. CRON or NON_CRON
	ScheduleType *ScheduleType `json:"scheduleType"`
	// Status of the latest experiment run
	Status *string `json:"status"`
	// Date range for filtering purpose
	DateRange *DateRange `json:"dateRange"`
	// Type of infras
	InfraTypes []*InfrastructureType `json:"infraTypes"`
}

type ExperimentRequest struct {
	// Name of the chart being used
	Category string `json:"category"`
	// Name of the experiment
	ExperimentName string `json:"experimentName"`
	// ID of the hub
	HubID string `json:"hubID"`
}

// Defines the details of a experiment run
type ExperimentRun struct {
	ProjectID string `json:"projectID"`
	// ID of the experiment run which is to be queried
	ExperimentRunID string `json:"experimentRunID"`
	// Type of the experiment
	ExperimentType *string `json:"experimentType"`
	// ID of the experiment
	ExperimentID string `json:"experimentID"`
	// Array containing weightage and name of each chaos fault in the experiment
	Weightages []*Weightages `json:"weightages"`
	// Timestamp at which experiment run was last updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp at which experiment run was created
	CreatedAt string `json:"createdAt"`
	// Target infra in which the experiment will run
	Infra *Infra `json:"infra"`
	// Name of the experiment
	ExperimentName string `json:"experimentName"`
	// Manifest of the experiment run
	ExperimentManifest string `json:"experimentManifest"`
	// Phase of the experiment run
	Phase ExperimentRunStatus `json:"phase"`
	// Resiliency score of the experiment
	ResiliencyScore *float64 `json:"resiliencyScore"`
	// Number of faults passed
	FaultsPassed *int `json:"faultsPassed"`
	// Number of faults failed
	FaultsFailed *int `json:"faultsFailed"`
	// Number of faults awaited
	FaultsAwaited *int `json:"faultsAwaited"`
	// Number of faults stopped
	FaultsStopped *int `json:"faultsStopped"`
	// Number of faults which are not available
	FaultsNa *int `json:"faultsNa"`
	// Total number of faults
	TotalFaults *int `json:"totalFaults"`
	// Stores all the experiment run details related to the nodes of DAG graph and chaos results of the faults
	ExecutionData string `json:"executionData"`
	// Bool value indicating if the experiment run has removed
	IsRemoved *bool `json:"isRemoved"`
	// User who has updated the experiment
	UpdatedBy *UserDetails `json:"updatedBy"`
	// User who has created the experiment run
	CreatedBy *UserDetails `json:"createdBy"`
	// Notify ID of the experiment run
	NotifyID *string `json:"notifyID"`
	// runSequence is the sequence number of experiment run
	RunSequence int `json:"runSequence"`
}

func (ExperimentRun) IsAudit() {}

// Defines input type for experiment run filter
type ExperimentRunFilterInput struct {
	// Name of the experiment
	ExperimentName *string `json:"experimentName"`
	// Name of the infra infra
	InfraID *string `json:"infraID"`
	// Type of the experiment
	ExperimentType *ScheduleType `json:"experimentType"`
	// Status of the experiment run
	ExperimentStatus *ExperimentRunStatus `json:"experimentStatus"`
	// Date range for filtering purpose
	DateRange *DateRange `json:"dateRange"`
	// ID of experiment run
	ExperimentRunID *string `json:"experimentRunID"`
	// Array of experiment run status
	ExperimentRunStatus []*string `json:"experimentRunStatus"`
	// Type of infras
	InfraTypes []*InfrastructureType `json:"infraTypes"`
}

// Defines the details for a experiment run
type ExperimentRunRequest struct {
	// ID of the experiment
	ExperimentID string `json:"experimentID"`
	// notifyID is required to give an ack for non cron experiment execution
	NotifyID *string `json:"notifyID"`
	// ID of the experiment run which is to be queried
	ExperimentRunID string `json:"experimentRunID"`
	// Name of the experiment
	ExperimentName string `json:"experimentName"`
	// Stores all the experiment run details related to the nodes of DAG graph and chaos results of the experiments
	ExecutionData string `json:"executionData"`
	// ID of the infra infra in which the experiment is running
	InfraID *InfraIdentity `json:"infraID"`
	// ID of the revision which consists manifest details
	RevisionID string `json:"revisionID"`
	// Bool value indicating if the experiment run has completed
	Completed bool `json:"completed"`
	// Bool value indicating if the experiment run has removed
	IsRemoved *bool `json:"isRemoved"`
	// User who has updated the experiment
	UpdatedBy string `json:"updatedBy"`
}

// Defines sorting options for experiment runs
type ExperimentRunSortInput struct {
	// Field in which sorting will be done
	Field ExperimentSortingField `json:"field"`
	// Bool value indicating whether the sorting will be done in ascending order
	Ascending *bool `json:"ascending"`
}

// Defines sorting options for experiment
type ExperimentSortInput struct {
	// Field in which sorting will be done
	Field ExperimentSortingField `json:"field"`
	// Bool value indicating whether the sorting will be done in ascending order
	Ascending *bool `json:"ascending"`
}

type Experiments struct {
	Name string `json:"name"`
	Csv  string `json:"CSV"`
	Desc string `json:"desc"`
}

// Fault Detail consists of all the fault related details
type FaultDetails struct {
	// fault consists of fault.yaml
	Fault string `json:"fault"`
	// engine consists engine.yaml
	Engine string `json:"engine"`
	// csv consists chartserviceversion.yaml
	Csv string `json:"csv"`
}

type FaultList struct {
	Name        string   `json:"name"`
	DisplayName string   `json:"displayName"`
	Description string   `json:"description"`
	Plan        []string `json:"plan"`
}

// Details of GET request
type Get struct {
	// Criteria of the request
	Criteria string `json:"criteria"`
	// Response Code of the request
	ResponseCode string `json:"responseCode"`
}

// Details for input of GET request
type GETRequest struct {
	// Criteria of the request
	Criteria string `json:"criteria"`
	// Response Code of the request
	ResponseCode string `json:"responseCode"`
}

type GetChaosHubStatsResponse struct {
	// Total number of chaoshubs
	TotalChaosHubs int `json:"totalChaosHubs"`
}

// Defines the details for a given experiment with some additional data
type GetExperimentResponse struct {
	// Details of experiment
	ExperimentDetails *Experiment `json:"experimentDetails"`
	// Average resiliency score of the experiment
	AverageResiliencyScore *float64 `json:"averageResiliencyScore"`
}

type GetExperimentRunStatsResponse struct {
	// Total number of experiment runs
	TotalExperimentRuns int `json:"totalExperimentRuns"`
	// Total number of completed experiments runs
	TotalCompletedExperimentRuns int `json:"totalCompletedExperimentRuns"`
	// Total number of stopped experiment runs
	TotalTerminatedExperimentRuns int `json:"totalTerminatedExperimentRuns"`
	// Total number of running experiment runs
	TotalRunningExperimentRuns int `json:"totalRunningExperimentRuns"`
	// Total number of stopped experiment runs
	TotalStoppedExperimentRuns int `json:"totalStoppedExperimentRuns"`
	// Total number of errored experiment runs
	TotalErroredExperimentRuns int `json:"totalErroredExperimentRuns"`
}

type GetExperimentStatsResponse struct {
	// Total number of experiments
	TotalExperiments int `json:"totalExperiments"`
	// Total number of cron experiments
	TotalExpCategorizedByResiliencyScore []*ResilienceScoreCategory `json:"totalExpCategorizedByResiliencyScore"`
}

type GetInfraStatsResponse struct {
	// Total number of infrastructures
	TotalInfrastructures int `json:"totalInfrastructures"`
	// Total number of active infrastructures
	TotalActiveInfrastructure int `json:"totalActiveInfrastructure"`
	// Total number of inactive infrastructures
	TotalInactiveInfrastructures int `json:"totalInactiveInfrastructures"`
	// Total number of confirmed infrastructures
	TotalConfirmedInfrastructure int `json:"totalConfirmedInfrastructure"`
	// Total number of non confirmed infrastructures
	TotalNonConfirmedInfrastructures int `json:"totalNonConfirmedInfrastructures"`
}

// Defines the response of the Probe reference API
type GetProbeReferenceResponse struct {
	// Harness identifiers
	ProjectID string `json:"projectID"`
	// Name of the Probe
	Name string `json:"name"`
	// Total Runs
	TotalRuns int `json:"totalRuns"`
	// Recent Executions of the probe
	RecentExecutions []*RecentExecutions `json:"recentExecutions"`
}

// Defines the input requests for GetProbeYAML query
type GetProbeYAMLRequest struct {
	// Probe name of the probe
	ProbeName string `json:"probeName"`
	// Mode of the Probe (SoT, EoT, Edge, Continuous or OnChaos)
	Mode Mode `json:"mode"`
}

// Defines the response for Get Probe In Experiment Run Query
type GetProbesInExperimentRunResponse struct {
	// Probe Object
	Probe *Probe `json:"probe"`
	// Mode of the probe
	Mode Mode `json:"mode"`
	// Status of the Probe
	Status *Status `json:"status"`
}

// Details of setting a Git repository
type GitConfig struct {
	// Git branch where the chaos charts will be pushed and synced
	Branch string `json:"branch"`
	// URL of the Git repository
	RepoURL string `json:"repoURL"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token used for private repository
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key authenticating into git repository
	SSHPrivateKey *string `json:"sshPrivateKey"`
}

// Response received after configuring GitOps
type GitConfigResponse struct {
	// Bool value indicating whether GitOps is enabled or not
	Enabled bool `json:"enabled"`
	// ID of the project where GitOps is configured
	ProjectID string `json:"projectID"`
	// Git branch where the chaos charts will be pushed and synced
	Branch *string `json:"branch"`
	// URL of the Git repository
	RepoURL *string `json:"repoURL"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType *AuthType `json:"authType"`
	// Token used for private repository
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key authenticating into git repository
	SSHPrivateKey *string `json:"sshPrivateKey"`
}

// Defines the input for HTTP probe properties
type HTTPProbeRequest struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// URL of the Probe
	URL string `json:"url"`
	// HTTP method of the Probe
	Method *MethodRequest `json:"method"`
	// If Insecure HTTP verification should  be skipped
	InsecureSkipVerify *bool `json:"insecureSkipVerify"`
}

// Defines details for image registry
type ImageRegistry struct {
	// Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
	IsDefault *bool `json:"isDefault"`
	// Name of Image Registry
	ImageRegistryName string `json:"imageRegistryName"`
	// Name of image repository
	ImageRepoName string `json:"imageRepoName"`
	// Type of the image registry: public/private
	ImageRegistryType string `json:"imageRegistryType"`
	// Secret which is used for private registry
	SecretName *string `json:"secretName"`
	// Namespace where the secret is available
	SecretNamespace *string `json:"secretNamespace"`
	// Bool value indicating if image registry is enabled or not
	EnableRegistry *bool `json:"enableRegistry"`
}

// Defines input data for querying the details of an image registry
type ImageRegistryInput struct {
	// Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
	IsDefault bool `json:"isDefault"`
	// Name of Image Registry
	ImageRegistryName string `json:"imageRegistryName"`
	// Name of image repository
	ImageRepoName string `json:"imageRepoName"`
	// Type of the image registry: public/private
	ImageRegistryType string `json:"imageRegistryType"`
	// Secret which is used for private registry
	SecretName *string `json:"secretName"`
	// Namespace where the secret is available
	SecretNamespace *string `json:"secretNamespace"`
	// Bool value indicating if image registry is enabled or not
	EnableRegistry *bool `json:"enableRegistry"`
}

// Defines response data for image registry
type ImageRegistryResponse struct {
	// Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
	IsDefault bool `json:"isDefault"`
	// Information Image Registry
	ImageRegistryInfo *ImageRegistry `json:"imageRegistryInfo"`
	// ID of the image registry
	ImageRegistryID string `json:"imageRegistryID"`
	// ID of the project in which image registry is created
	ProjectID string `json:"projectID"`
	// Timestamp when the image registry was last updated
	UpdatedAt *string `json:"updatedAt"`
	// Timestamp when the image registry was created
	CreatedAt *string `json:"createdAt"`
	// User who created the infra
	CreatedBy *UserDetails `json:"createdBy"`
	// User who has updated the infra
	UpdatedBy *UserDetails `json:"updatedBy"`
	// Bool value indicating if the image registry has been removed
	IsRemoved *bool `json:"isRemoved"`
}

func (ImageRegistryResponse) IsAudit() {}

// Defines the details for a infra
type Infra struct {
	ProjectID string `json:"projectID"`
	// ID of the infra
	InfraID string `json:"infraID"`
	// Name of the infra
	Name string `json:"name"`
	// Description of the infra
	Description *string `json:"description"`
	// Tags of the infra
	Tags []string `json:"tags"`
	// Environment ID for the infra
	EnvironmentID string `json:"environmentID"`
	// Infra Platform Name eg. GKE,AWS, Others
	PlatformName string `json:"platformName"`
	// Boolean value indicating if chaos infrastructure is active or not
	IsActive bool `json:"isActive"`
	// Boolean value indicating if chaos infrastructure is confirmed or not
	IsInfraConfirmed bool `json:"isInfraConfirmed"`
	// Boolean value indicating if chaos infrastructure is removed or not
	IsRemoved bool `json:"isRemoved"`
	// Timestamp when the infra was last updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp when the infra was created
	CreatedAt string `json:"createdAt"`
	// Number of schedules created in the infra
	NoOfExperiments *int `json:"noOfExperiments"`
	// Number of experiments run in the infra
	NoOfExperimentRuns *int `json:"noOfExperimentRuns"`
	// Token used to verify and retrieve the infra manifest
	Token string `json:"token"`
	// Namespace where the infra is being installed
	InfraNamespace *string `json:"infraNamespace"`
	// Name of service account used by infra
	ServiceAccount *string `json:"serviceAccount"`
	// Scope of the infra : ns or cluster
	InfraScope string `json:"infraScope"`
	// Bool value indicating whether infra ns used already exists on infra or not
	InfraNsExists *bool `json:"infraNsExists"`
	// Bool value indicating whether service account used already exists on infra or not
	InfraSaExists *bool `json:"infraSaExists"`
	// Timestamp of the last experiment run in the infra
	LastExperimentTimestamp *string `json:"lastExperimentTimestamp"`
	// Timestamp when the infra got connected
	StartTime string `json:"startTime"`
	// Version of the infra
	Version string `json:"version"`
	// User who created the infra
	CreatedBy *UserDetails `json:"createdBy"`
	// User who has updated the infra
	UpdatedBy *UserDetails `json:"updatedBy"`
	// Type of the infrastructure
	InfraType *InfrastructureType `json:"infraType"`
	// update status of infra
	UpdateStatus UpdateStatus `json:"updateStatus"`
}

func (Infra) IsResourceDetails() {}
func (Infra) IsAudit()           {}

type InfraActionResponse struct {
	ProjectID string         `json:"projectID"`
	Action    *ActionPayload `json:"action"`
}

type InfraEventResponse struct {
	EventID     string `json:"eventID"`
	EventType   string `json:"eventType"`
	EventName   string `json:"eventName"`
	Description string `json:"description"`
	Infra       *Infra `json:"infra"`
}

// Defines filter options for infras
type InfraFilterInput struct {
	// Name of the infra
	Name *string `json:"name"`
	// ID of the infra
	InfraID *string `json:"infraID"`
	// ID of the infra
	Description *string `json:"description"`
	// Platform name of infra
	PlatformName *string `json:"platformName"`
	// Scope of infra
	InfraScope *InfraScope `json:"infraScope"`
	// Status of infra
	IsActive *bool `json:"isActive"`
	// Tags of an infra
	Tags []*string `json:"tags"`
}

type InfraIdentity struct {
	InfraID   string `json:"infraID"`
	AccessKey string `json:"accessKey"`
	Version   string `json:"version"`
}

// InfraVersionDetails returns the details of compatible infra versions and the latest infra version supported
type InfraVersionDetails struct {
	// Latest infra version supported
	LatestVersion string `json:"latestVersion"`
	// List of all infra versions supported
	CompatibleVersions []string `json:"compatibleVersions"`
}

// Defines the K8S probe properties
type K8SProbe struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// Group of the Probe
	Group *string `json:"group"`
	// Version of the Probe
	Version string `json:"version"`
	// Resource of the Probe
	Resource string `json:"resource"`
	// Namespace of the Probe
	Namespace *string `json:"namespace"`
	// Resource Names of the Probe
	ResourceNames *string `json:"resourceNames"`
	// Field Selector of the Probe
	FieldSelector *string `json:"fieldSelector"`
	// Label Selector of the Probe
	LabelSelector *string `json:"labelSelector"`
	// Operation of the Probe
	Operation string `json:"operation"`
}

func (K8SProbe) IsCommonProbeProperties() {}

// Defines the input for K8S probe properties
type K8SProbeRequest struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// Group of the Probe
	Group *string `json:"group"`
	// Version of the Probe
	Version string `json:"version"`
	// Resource of the Probe
	Resource string `json:"resource"`
	// Namespace of the Probe
	Namespace *string `json:"namespace"`
	// Resource Names of the Probe
	ResourceNames *string `json:"resourceNames"`
	// Field Selector of the Probe
	FieldSelector *string `json:"fieldSelector"`
	// Label Selector of the Probe
	LabelSelector *string `json:"labelSelector"`
	// Operation of the Probe
	Operation string `json:"operation"`
}

type KubeGVRRequest struct {
	Group    string `json:"group"`
	Version  string `json:"version"`
	Resource string `json:"resource"`
}

// KubeObject consists of the namespace and the available resources in the same
type KubeObject struct {
	// Namespace of the resource
	Namespace string `json:"namespace"`
	// Details of the resource
	Data []*ObjectData `json:"data"`
}

// Defines the details of Kubernetes object
type KubeObjectData struct {
	// Unique request ID for fetching Kubernetes object details
	RequestID string `json:"requestID"`
	// ID of the infra in which the Kubernetes object is present
	InfraID *InfraIdentity `json:"infraID"`
	// Type of the Kubernetes object
	KubeObj string `json:"kubeObj"`
}

// Defines details for fetching Kubernetes object data
type KubeObjectRequest struct {
	// ID of the infra in which the Kubernetes object is present
	InfraID string `json:"infraID"`
	// GVR Request
	KubeObjRequest *KubeGVRRequest `json:"kubeObjRequest"`
	ObjectType     string          `json:"objectType"`
	Workloads      []*Workload     `json:"workloads"`
}

// Response received for querying Kubernetes Object
type KubeObjectResponse struct {
	// ID of the infra in which the Kubernetes object is present
	InfraID string `json:"infraID"`
	// Type of the Kubernetes object
	KubeObj []*KubeObject `json:"kubeObj"`
}

// Defines the CMD probe properties
type KubernetesCMDProbe struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// Command of the Probe
	Command string `json:"command"`
	// Comparator of the Probe
	Comparator *Comparator `json:"comparator"`
	// Source of the Probe
	Source *string `json:"source"`
}

func (KubernetesCMDProbe) IsCommonProbeProperties() {}

// Defines the input for Kubernetes CMD probe properties
type KubernetesCMDProbeRequest struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// Command of the Probe
	Command string `json:"command"`
	// Comparator of the Probe
	Comparator *ComparatorInput `json:"comparator"`
	// Source of the Probe
	Source *string `json:"source"`
}

// Defines the Kubernetes HTTP probe properties
type KubernetesHTTPProbe struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// URL of the Probe
	URL string `json:"url"`
	// HTTP method of the Probe
	Method *Method `json:"method"`
	// If Insecure HTTP verification should  be skipped
	InsecureSkipVerify *bool `json:"insecureSkipVerify"`
}

func (KubernetesHTTPProbe) IsCommonProbeProperties() {}

// Defines the input for Kubernetes HTTP probe properties
type KubernetesHTTPProbeRequest struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// URL of the Probe
	URL string `json:"url"`
	// HTTP method of the Probe
	Method *MethodRequest `json:"method"`
	// If Insecure HTTP verification should  be skipped
	InsecureSkipVerify *bool `json:"insecureSkipVerify"`
}

type Link struct {
	Name string `json:"name"`
	URL  string `json:"url"`
}

type ListChaosHubRequest struct {
	// Array of ChaosHub IDs for which details will be fetched
	ChaosHubIDs []string `json:"chaosHubIDs"`
	// Details for fetching filtered data
	Filter *ChaosHubFilterInput `json:"filter"`
}

type ListEnvironmentRequest struct {
	// Environment ID
	EnvironmentIDs []string `json:"environmentIDs"`
	// Details for fetching paginated data
	Pagination *Pagination `json:"pagination"`
	// Details for fetching filtered data
	Filter *EnvironmentFilterInput `json:"filter"`
	// Details for fetching sorted data
	Sort *EnvironmentSortInput `json:"sort"`
}

type ListEnvironmentResponse struct {
	// Total number of environment
	TotalNoOfEnvironments int            `json:"totalNoOfEnvironments"`
	Environments          []*Environment `json:"environments"`
}

// Defines the details for a experiment
type ListExperimentRequest struct {
	// Array of experiment IDs for which details will be fetched
	ExperimentIDs []*string `json:"experimentIDs"`
	// Details for fetching paginated data
	Pagination *Pagination `json:"pagination"`
	// Details for fetching sorted data
	Sort *ExperimentSortInput `json:"sort"`
	// Details for fetching filtered data
	Filter *ExperimentFilterInput `json:"filter"`
}

// Defines the details for a experiment with total experiment count
type ListExperimentResponse struct {
	// Total number of experiments
	TotalNoOfExperiments int `json:"totalNoOfExperiments"`
	// Details related to the experiments
	Experiments []*Experiment `json:"experiments"`
}

// Defines the details for experiment runs
type ListExperimentRunRequest struct {
	// Array of experiment run IDs for which details will be fetched
	ExperimentRunIDs []*string `json:"experimentRunIDs"`
	// Array of experiment IDs for which details will be fetched
	ExperimentIDs []*string `json:"experimentIDs"`
	// Details for fetching paginated data
	Pagination *Pagination `json:"pagination"`
	// Details for fetching sorted data
	Sort *ExperimentRunSortInput `json:"sort"`
	// Details for fetching filtered data
	Filter *ExperimentRunFilterInput `json:"filter"`
}

// Defines the details of a experiment to sent as response
type ListExperimentRunResponse struct {
	// Total number of experiment runs
	TotalNoOfExperimentRuns int `json:"totalNoOfExperimentRuns"`
	// Defines details of experiment runs
	ExperimentRuns []*ExperimentRun `json:"experimentRuns"`
}

// Defines the details for a infra
type ListInfraRequest struct {
	// Array of infra IDs for which details will be fetched
	InfraIDs []string `json:"infraIDs"`
	// Environment ID
	EnvironmentIDs []string `json:"environmentIDs"`
	// Details for fetching paginated data
	Pagination *Pagination `json:"pagination"`
	// Details for fetching filtered data
	Filter *InfraFilterInput `json:"filter"`
}

// Defines the details for a infras with total infras count
type ListInfraResponse struct {
	// Total number of infras
	TotalNoOfInfras int `json:"totalNoOfInfras"`
	// Details related to the infras
	Infras []*Infra `json:"infras"`
}

// Defines the details of the maintainer
type Maintainer struct {
	// Name of the maintainer
	Name string `json:"name"`
	// Email of the maintainer
	Email string `json:"email"`
}

type Metadata struct {
	Name        string      `json:"name"`
	Version     string      `json:"version"`
	Annotations *Annotation `json:"annotations"`
}

// Defines the methods of the probe properties
type Method struct {
	// A GET request
	Get *Get `json:"get"`
	// A POST request
	Post *Post `json:"post"`
}

// Defines the input for methods of the probe properties
type MethodRequest struct {
	// A GET request
	Get *GETRequest `json:"get"`
	// A POST request
	Post *POSTRequest `json:"post"`
}

type NewInfraEventRequest struct {
	EventName   string `json:"eventName"`
	Description string `json:"description"`
	InfraID     string `json:"infraID"`
	AccessKey   string `json:"accessKey"`
}

type ObjectData struct {
	// Labels present in the resource
	Labels []string `json:"labels"`
	// Name of the resource
	Name string `json:"name"`
}

// Details of POST request
type Post struct {
	// Content Type of the request
	ContentType *string `json:"contentType"`
	// Body of the request
	Body *string `json:"body"`
	// Body Path of the HTTP body required for the http post request
	BodyPath *string `json:"bodyPath"`
	// Criteria of the request
	Criteria string `json:"criteria"`
	// Response Code of the request
	ResponseCode string `json:"responseCode"`
}

// Details for input of the POST request
type POSTRequest struct {
	// Content Type of the request
	ContentType *string `json:"contentType"`
	// Body of the request
	Body *string `json:"body"`
	// Body Path of the request for Body
	BodyPath *string `json:"bodyPath"`
	// Criteria of the request
	Criteria string `json:"criteria"`
	// Response Code of the request
	ResponseCode string `json:"responseCode"`
}

// Defines the PROM probe properties
type PROMProbe struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// Endpoint of the Probe
	Endpoint string `json:"endpoint"`
	// Query of the Probe
	Query *string `json:"query"`
	// Query path of the Probe
	QueryPath *string `json:"queryPath"`
	// Comparator of the Probe
	Comparator *Comparator `json:"comparator"`
}

func (PROMProbe) IsCommonProbeProperties() {}

// Defines the input for PROM probe properties
type PROMProbeRequest struct {
	// Timeout of the Probe
	ProbeTimeout string `json:"probeTimeout"`
	// Interval of the Probe
	Interval string `json:"interval"`
	// Retry interval of the Probe
	Retry *int `json:"retry"`
	// Attempt contains the total attempt count for the probe
	Attempt *int `json:"attempt"`
	// Polling interval of the Probe
	ProbePollingInterval *string `json:"probePollingInterval"`
	// Initial delay interval of the Probe in seconds
	InitialDelay *string `json:"initialDelay"`
	// EvaluationTimeout is the timeout window in which the SLO metrics
	EvaluationTimeout *string `json:"evaluationTimeout"`
	// Is stop on failure enabled in the Probe
	StopOnFailure *bool `json:"stopOnFailure"`
	// Endpoint of the Probe
	Endpoint string `json:"endpoint"`
	// Query of the Probe
	Query *string `json:"query"`
	// Query path of the Probe
	QueryPath *string `json:"queryPath"`
	// Comparator of the Probe
	Comparator *ComparatorInput `json:"comparator"`
}

type PackageInformation struct {
	PackageName string         `json:"packageName"`
	Experiments []*Experiments `json:"experiments"`
}

// Defines data required to fetch paginated data
type Pagination struct {
	// Page number for which data will be fetched
	Page int `json:"page"`
	// Number of data to be fetched
	Limit int `json:"limit"`
}

// Response received for querying pod logs
type PodLog struct {
	// ID of the cluster
	InfraID *InfraIdentity `json:"infraID"`
	// Unique request ID of a particular node which is being queried
	RequestID string `json:"requestID"`
	// ID of a experiment run
	ExperimentRunID string `json:"experimentRunID"`
	// Name of the pod for which logs are required
	PodName string `json:"podName"`
	// Type of the pod: chaosengine
	PodType string `json:"podType"`
	// Logs for the pod
	Log string `json:"log"`
}

// Defines the details for fetching the pod logs
type PodLogRequest struct {
	// ID of the cluster
	InfraID string `json:"infraID"`
	// ID of a experiment run
	ExperimentRunID string `json:"experimentRunID"`
	// Name of the pod for which logs are required
	PodName string `json:"podName"`
	// Namespace where the pod is running
	PodNamespace string `json:"podNamespace"`
	// Type of the pod: chaosEngine or not pod
	PodType string `json:"podType"`
	// Name of the experiment pod fetched from execution data
	ExpPod *string `json:"expPod"`
	// Name of the runner pod fetched from execution data
	RunnerPod *string `json:"runnerPod"`
	// Namespace where the experiment is executing
	ChaosNamespace *string `json:"chaosNamespace"`
}

// Defines the response received for querying querying the pod logs
type PodLogResponse struct {
	// ID of the experiment run which is to be queried
	ExperimentRunID string `json:"experimentRunID"`
	// Name of the pod for which logs are queried
	PodName string `json:"podName"`
	// Type of the pod: chaosengine
	PodType string `json:"podType"`
	// Logs for the pod
	Log string `json:"log"`
}

type PredefinedExperimentList struct {
	// Name of the experiment
	ExperimentName string `json:"experimentName"`
	// Experiment CSV
	ExperimentCsv string `json:"experimentCSV"`
	// Experiment Manifest
	ExperimentManifest string `json:"experimentManifest"`
}

// Defines the details of the Probe entity
type Probe struct {
	// Harness identifiers
	ProjectID string `json:"projectID"`
	// Name of the Probe
	Name string `json:"name"`
	// Description of the Probe
	Description *string `json:"description"`
	// Tags of the Probe
	Tags []string `json:"tags"`
	// Type of the Probe [From list of ProbeType enum]
	Type ProbeType `json:"type"`
	// Infrastructure type of the Probe
	InfrastructureType InfrastructureType `json:"infrastructureType"`
	// Kubernetes HTTP Properties of the specific type of the Probe
	KubernetesHTTPProperties *KubernetesHTTPProbe `json:"kubernetesHTTPProperties"`
	// Kubernetes CMD Properties of the specific type of the Probe
	KubernetesCMDProperties *KubernetesCMDProbe `json:"kubernetesCMDProperties"`
	// K8S Properties of the specific type of the Probe
	K8sProperties *K8SProbe `json:"k8sProperties"`
	// PROM Properties of the specific type of the Probe
	PromProperties *PROMProbe `json:"promProperties"`
	// All execution histories of the probe
	RecentExecutions []*ProbeRecentExecutions `json:"recentExecutions"`
	// Referenced by how many faults
	ReferencedBy *int `json:"referencedBy"`
	// Timestamp at which the Probe was last updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp at which the Probe was created
	CreatedAt string `json:"createdAt"`
	// User who has updated the Probe
	UpdatedBy *UserDetails `json:"updatedBy"`
	// User who has created the Probe
	CreatedBy *UserDetails `json:"createdBy"`
}

func (Probe) IsResourceDetails() {}
func (Probe) IsAudit()           {}

// Defines the input for Probe filter
type ProbeFilterInput struct {
	// Name of the Probe
	Name *string `json:"name"`
	// Date range for filtering purpose
	DateRange *DateRange `json:"dateRange"`
	// Type of the Probe [From list of ProbeType enum]
	Type []*ProbeType `json:"type"`
}

// Defines the Recent Executions of global probe in ListProbe API with different fault and execution history each time
type ProbeRecentExecutions struct {
	// Fault name
	FaultName string `json:"faultName"`
	// Fault Status
	Status *Status `json:"status"`
	// Fault executed by which experiment
	ExecutedByExperiment *ExecutedByExperiment `json:"executedByExperiment"`
}

// Defines the details required for creating a Chaos Probe
type ProbeRequest struct {
	// Name of the Probe
	Name string `json:"name"`
	// Description of the Probe
	Description *string `json:"description"`
	// Tags of the Probe
	Tags []string `json:"tags"`
	// Type of the Probe [From list of ProbeType enum]
	Type ProbeType `json:"type"`
	// Infrastructure type of the Probe
	InfrastructureType InfrastructureType `json:"infrastructureType"`
	// HTTP Properties of the specific type of the Probe
	KubernetesHTTPProperties *KubernetesHTTPProbeRequest `json:"kubernetesHTTPProperties"`
	// CMD Properties of the specific type of the Probe
	KubernetesCMDProperties *KubernetesCMDProbeRequest `json:"kubernetesCMDProperties"`
	// K8S Properties of the specific type of the Probe
	K8sProperties *K8SProbeRequest `json:"k8sProperties"`
	// PROM Properties of the specific type of the Probe
	PromProperties *PROMProbeRequest `json:"promProperties"`
}

type Provider struct {
	Name string `json:"name"`
}

// Defines the Recent Executions of experiment referenced by the Probe
type RecentExecutions struct {
	// Fault name
	FaultName string `json:"faultName"`
	// Probe mode
	Mode Mode `json:"mode"`
	// Execution History
	ExecutionHistory []*ExecutionHistory `json:"executionHistory"`
}

type RecentExperimentRun struct {
	// ID of the experiment run which is to be queried
	ExperimentRunID string `json:"experimentRunID"`
	// Phase of the experiment run
	Phase string `json:"phase"`
	// Resiliency score of the experiment
	ResiliencyScore *float64 `json:"resiliencyScore"`
	// Timestamp when the experiment was last updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp when the experiment was created
	CreatedAt string `json:"createdAt"`
	// User who created the experiment run
	CreatedBy *UserDetails `json:"createdBy"`
	// User who updated the experiment run
	UpdatedBy *UserDetails `json:"updatedBy"`
	// runSequence is the sequence number of experiment run
	RunSequence int `json:"runSequence"`
}

func (RecentExperimentRun) IsAudit() {}

// Defines the details for the new infra being connected
type RegisterInfraRequest struct {
	// Name of the infra
	Name string `json:"name"`
	// Environment ID for the infra
	EnvironmentID string `json:"environmentID"`
	// Type of Infra : internal/external
	InfrastructureType InfrastructureType `json:"infrastructureType"`
	// Description of the infra
	Description *string `json:"description"`
	// Infra Platform Name eg. GKE,AWS, Others
	PlatformName string `json:"platformName"`
	// Namespace where the infra is being installed
	InfraNamespace *string `json:"infraNamespace"`
	// Name of service account used by infra
	ServiceAccount *string `json:"serviceAccount"`
	// Scope of the infra : ns or infra
	InfraScope string `json:"infraScope"`
	// Bool value indicating whether infra ns used already exists on infra or not
	InfraNsExists *bool `json:"infraNsExists"`
	// Bool value indicating whether service account used already exists on infra or not
	InfraSaExists *bool `json:"infraSaExists"`
	// Bool value indicating whether infra will skip ssl checks or not
	SkipSsl *bool `json:"skipSsl"`
	// Node selectors used by infra
	NodeSelector *string `json:"nodeSelector"`
	// Node tolerations used by infra
	Tolerations []*Toleration `json:"tolerations"`
	// Tags of the infra
	Tags []string `json:"tags"`
}

// Response received for registering a new infra
type RegisterInfraResponse struct {
	// Token used to verify and retrieve the infra manifest
	Token string `json:"token"`
	// Unique ID for the newly registered infra
	InfraID string `json:"infraID"`
	// Infra name as sent in request
	Name string `json:"name"`
	// Infra Manifest
	Manifest string `json:"manifest"`
}

type ResilienceScoreCategory struct {
	// Lower bound of the range(inclusive)
	ID int `json:"id"`
	// total experiments with avg resilience score between lower bound and upper bound(exclusive)
	Count int `json:"count"`
}

type RunChaosExperimentResponse struct {
	NotifyID string `json:"notifyID"`
}

// Defines the SSHKey details
type SSHKey struct {
	// Public SSH key authenticating into git repository
	PublicKey string `json:"publicKey"`
	// Private SSH key authenticating into git repository
	PrivateKey string `json:"privateKey"`
}

// Defines the details for a chaos experiment
type SaveChaosExperimentRequest struct {
	// ID of the experiment
	ID string `json:"id"`
	// Type of the experiment
	Type *ExperimentType `json:"type"`
	// Name of the experiment
	Name string `json:"name"`
	// Description of the experiment
	Description string `json:"description"`
	// Manifest of the experiment
	Manifest string `json:"manifest"`
	// ID of the target infrastructure in which the experiment will run
	InfraID string `json:"infraID"`
	// Tags of the infrastructure
	Tags []string `json:"tags"`
}

// Response received for fetching GQL server version
type ServerVersionResponse struct {
	// Returns server version key
	Key string `json:"key"`
	// Returns server version value
	Value string `json:"value"`
}

type Spec struct {
	DisplayName         string        `json:"displayName"`
	CategoryDescription string        `json:"categoryDescription"`
	Keywords            []string      `json:"keywords"`
	Maturity            string        `json:"maturity"`
	Maintainers         []*Maintainer `json:"maintainers"`
	MinKubeVersion      string        `json:"minKubeVersion"`
	Provider            *Provider     `json:"provider"`
	Links               []*Link       `json:"links"`
	Faults              []*FaultList  `json:"faults"`
	Experiments         []string      `json:"experiments"`
	ChaosExpCRDLink     string        `json:"chaosExpCRDLink"`
	Platforms           []string      `json:"platforms"`
	ChaosType           *string       `json:"chaosType"`
}

// Status defines whether a probe is pass or fail
type Status struct {
	// Verdict defines the verdict of the probe, range: Passed, Failed, N/A
	Verdict ProbeVerdict `json:"verdict"`
	// Description defines the description of probe status
	Description *string `json:"description"`
}

// Defines the request for stopping a experiment
type StopExperimentRunsRequest struct {
	ProjectID string `json:"projectID"`
	// ID of the experiment to be stopped
	ExperimentID string `json:"experimentID"`
	// ID of the experiment run to be stopped
	ExperimentRunID *string `json:"experimentRunID"`
}

type Toleration struct {
	TolerationSeconds *int    `json:"tolerationSeconds"`
	Key               *string `json:"key"`
	Operator          *string `json:"operator"`
	Effect            *string `json:"effect"`
	Value             *string `json:"value"`
}

type UpdateChaosHubRequest struct {
	// ID of the chaos hub
	ID string `json:"id"`
	// Name of the chaos hub
	Name string `json:"name"`
	// Description of the infra
	Description *string `json:"description"`
	// Tags of the infra
	Tags []string `json:"tags"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key for authenticating into private chaos hub
	SSHPrivateKey *string `json:"sshPrivateKey"`
	// Public SSH key for authenticating into private chaos hub
	SSHPublicKey *string `json:"sshPublicKey"`
}

type UpdateEnvironmentRequest struct {
	EnvironmentID string           `json:"environmentID"`
	Name          *string          `json:"name"`
	Description   *string          `json:"description"`
	Tags          []*string        `json:"tags"`
	Type          *EnvironmentType `json:"type"`
}

type UserDetails struct {
	UserID   string `json:"userID"`
	Username string `json:"username"`
	Email    string `json:"email"`
}

// Defines the details of the weightages of each chaos fault in the experiment
type Weightages struct {
	// Name of the fault
	FaultName string `json:"faultName"`
	// Weightage of the experiment
	Weightage int `json:"weightage"`
}

// Defines the details of the weightages of each chaos fault in the experiment
type WeightagesInput struct {
	// Name of the fault
	FaultName string `json:"faultName"`
	// Weightage of the fault
	Weightage int `json:"weightage"`
}

type Workload struct {
	Name      string `json:"name"`
	Kind      string `json:"kind"`
	Namespace string `json:"namespace"`
}

type AuthType string

const (
	AuthTypeBasic AuthType = "BASIC"
	AuthTypeNone  AuthType = "NONE"
	AuthTypeSSH   AuthType = "SSH"
	AuthTypeToken AuthType = "TOKEN"
)

var AllAuthType = []AuthType{
	AuthTypeBasic,
	AuthTypeNone,
	AuthTypeSSH,
	AuthTypeToken,
}

func (e AuthType) IsValid() bool {
	switch e {
	case AuthTypeBasic, AuthTypeNone, AuthTypeSSH, AuthTypeToken:
		return true
	}
	return false
}

func (e AuthType) String() string {
	return string(e)
}

func (e *AuthType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthType", str)
	}
	return nil
}

func (e AuthType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EnvironmentSortingField string

const (
	EnvironmentSortingFieldName EnvironmentSortingField = "NAME"
	EnvironmentSortingFieldTime EnvironmentSortingField = "TIME"
)

var AllEnvironmentSortingField = []EnvironmentSortingField{
	EnvironmentSortingFieldName,
	EnvironmentSortingFieldTime,
}

func (e EnvironmentSortingField) IsValid() bool {
	switch e {
	case EnvironmentSortingFieldName, EnvironmentSortingFieldTime:
		return true
	}
	return false
}

func (e EnvironmentSortingField) String() string {
	return string(e)
}

func (e *EnvironmentSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentSortingField", str)
	}
	return nil
}

func (e EnvironmentSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EnvironmentType string

const (
	EnvironmentTypeProd    EnvironmentType = "PROD"
	EnvironmentTypeNonProd EnvironmentType = "NON_PROD"
)

var AllEnvironmentType = []EnvironmentType{
	EnvironmentTypeProd,
	EnvironmentTypeNonProd,
}

func (e EnvironmentType) IsValid() bool {
	switch e {
	case EnvironmentTypeProd, EnvironmentTypeNonProd:
		return true
	}
	return false
}

func (e EnvironmentType) String() string {
	return string(e)
}

func (e *EnvironmentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentType", str)
	}
	return nil
}

func (e EnvironmentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ExperimentRunStatus string

const (
	ExperimentRunStatusAll                ExperimentRunStatus = "All"
	ExperimentRunStatusRunning            ExperimentRunStatus = "Running"
	ExperimentRunStatusCompleted          ExperimentRunStatus = "Completed"
	ExperimentRunStatusCompletedWithError ExperimentRunStatus = "Completed_With_Error"
	ExperimentRunStatusStopped            ExperimentRunStatus = "Stopped"
	ExperimentRunStatusSkipped            ExperimentRunStatus = "Skipped"
	ExperimentRunStatusError              ExperimentRunStatus = "Error"
	ExperimentRunStatusTimeout            ExperimentRunStatus = "Timeout"
	ExperimentRunStatusNa                 ExperimentRunStatus = "NA"
)

var AllExperimentRunStatus = []ExperimentRunStatus{
	ExperimentRunStatusAll,
	ExperimentRunStatusRunning,
	ExperimentRunStatusCompleted,
	ExperimentRunStatusCompletedWithError,
	ExperimentRunStatusStopped,
	ExperimentRunStatusSkipped,
	ExperimentRunStatusError,
	ExperimentRunStatusTimeout,
	ExperimentRunStatusNa,
}

func (e ExperimentRunStatus) IsValid() bool {
	switch e {
	case ExperimentRunStatusAll, ExperimentRunStatusRunning, ExperimentRunStatusCompleted, ExperimentRunStatusCompletedWithError, ExperimentRunStatusStopped, ExperimentRunStatusSkipped, ExperimentRunStatusError, ExperimentRunStatusTimeout, ExperimentRunStatusNa:
		return true
	}
	return false
}

func (e ExperimentRunStatus) String() string {
	return string(e)
}

func (e *ExperimentRunStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentRunStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExperimentRunStatus", str)
	}
	return nil
}

func (e ExperimentRunStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ExperimentSortingField string

const (
	ExperimentSortingFieldName ExperimentSortingField = "NAME"
	ExperimentSortingFieldTime ExperimentSortingField = "TIME"
)

var AllExperimentSortingField = []ExperimentSortingField{
	ExperimentSortingFieldName,
	ExperimentSortingFieldTime,
}

func (e ExperimentSortingField) IsValid() bool {
	switch e {
	case ExperimentSortingFieldName, ExperimentSortingFieldTime:
		return true
	}
	return false
}

func (e ExperimentSortingField) String() string {
	return string(e)
}

func (e *ExperimentSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExperimentSortingField", str)
	}
	return nil
}

func (e ExperimentSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ExperimentType string

const (
	ExperimentTypeAll            ExperimentType = "All"
	ExperimentTypeExperiment     ExperimentType = "Experiment"
	ExperimentTypeCronExperiment ExperimentType = "CronExperiment"
	ExperimentTypeChaosEngine    ExperimentType = "ChaosEngine"
	ExperimentTypeChaosSchedule  ExperimentType = "ChaosSchedule"
)

var AllExperimentType = []ExperimentType{
	ExperimentTypeAll,
	ExperimentTypeExperiment,
	ExperimentTypeCronExperiment,
	ExperimentTypeChaosEngine,
	ExperimentTypeChaosSchedule,
}

func (e ExperimentType) IsValid() bool {
	switch e {
	case ExperimentTypeAll, ExperimentTypeExperiment, ExperimentTypeCronExperiment, ExperimentTypeChaosEngine, ExperimentTypeChaosSchedule:
		return true
	}
	return false
}

func (e ExperimentType) String() string {
	return string(e)
}

func (e *ExperimentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExperimentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExperimentType", str)
	}
	return nil
}

func (e ExperimentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FileType string

const (
	FileTypeExperiment FileType = "EXPERIMENT"
	FileTypeEngine     FileType = "ENGINE"
	FileTypeWorkflow   FileType = "WORKFLOW"
	FileTypeCsv        FileType = "CSV"
)

var AllFileType = []FileType{
	FileTypeExperiment,
	FileTypeEngine,
	FileTypeWorkflow,
	FileTypeCsv,
}

func (e FileType) IsValid() bool {
	switch e {
	case FileTypeExperiment, FileTypeEngine, FileTypeWorkflow, FileTypeCsv:
		return true
	}
	return false
}

func (e FileType) String() string {
	return string(e)
}

func (e *FileType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileType", str)
	}
	return nil
}

func (e FileType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HubType string

const (
	HubTypeGit    HubType = "GIT"
	HubTypeRemote HubType = "REMOTE"
)

var AllHubType = []HubType{
	HubTypeGit,
	HubTypeRemote,
}

func (e HubType) IsValid() bool {
	switch e {
	case HubTypeGit, HubTypeRemote:
		return true
	}
	return false
}

func (e HubType) String() string {
	return string(e)
}

func (e *HubType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HubType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HubType", str)
	}
	return nil
}

func (e HubType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InfraScope string

const (
	InfraScopeNamespace InfraScope = "namespace"
	InfraScopeCluster   InfraScope = "cluster"
)

var AllInfraScope = []InfraScope{
	InfraScopeNamespace,
	InfraScopeCluster,
}

func (e InfraScope) IsValid() bool {
	switch e {
	case InfraScopeNamespace, InfraScopeCluster:
		return true
	}
	return false
}

func (e InfraScope) String() string {
	return string(e)
}

func (e *InfraScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InfraScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid INFRA_SCOPE", str)
	}
	return nil
}

func (e InfraScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Defines the different types of Image Pull Policy
type ImagePullPolicy string

const (
	ImagePullPolicyIfNotPresent ImagePullPolicy = "IfNotPresent"
	ImagePullPolicyAlways       ImagePullPolicy = "Always"
	ImagePullPolicyNever        ImagePullPolicy = "Never"
)

var AllImagePullPolicy = []ImagePullPolicy{
	ImagePullPolicyIfNotPresent,
	ImagePullPolicyAlways,
	ImagePullPolicyNever,
}

func (e ImagePullPolicy) IsValid() bool {
	switch e {
	case ImagePullPolicyIfNotPresent, ImagePullPolicyAlways, ImagePullPolicyNever:
		return true
	}
	return false
}

func (e ImagePullPolicy) String() string {
	return string(e)
}

func (e *ImagePullPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImagePullPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImagePullPolicy", str)
	}
	return nil
}

func (e ImagePullPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InfrastructureType string

const (
	InfrastructureTypeKubernetes InfrastructureType = "Kubernetes"
)

var AllInfrastructureType = []InfrastructureType{
	InfrastructureTypeKubernetes,
}

func (e InfrastructureType) IsValid() bool {
	switch e {
	case InfrastructureTypeKubernetes:
		return true
	}
	return false
}

func (e InfrastructureType) String() string {
	return string(e)
}

func (e *InfrastructureType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InfrastructureType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InfrastructureType", str)
	}
	return nil
}

func (e InfrastructureType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Invitation string

const (
	InvitationAccepted Invitation = "Accepted"
	InvitationPending  Invitation = "Pending"
)

var AllInvitation = []Invitation{
	InvitationAccepted,
	InvitationPending,
}

func (e Invitation) IsValid() bool {
	switch e {
	case InvitationAccepted, InvitationPending:
		return true
	}
	return false
}

func (e Invitation) String() string {
	return string(e)
}

func (e *Invitation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Invitation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Invitation", str)
	}
	return nil
}

func (e Invitation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MemberRole string

const (
	MemberRoleOwner  MemberRole = "Owner"
	MemberRoleEditor MemberRole = "Editor"
	MemberRoleViewer MemberRole = "Viewer"
)

var AllMemberRole = []MemberRole{
	MemberRoleOwner,
	MemberRoleEditor,
	MemberRoleViewer,
}

func (e MemberRole) IsValid() bool {
	switch e {
	case MemberRoleOwner, MemberRoleEditor, MemberRoleViewer:
		return true
	}
	return false
}

func (e MemberRole) String() string {
	return string(e)
}

func (e *MemberRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberRole", str)
	}
	return nil
}

func (e MemberRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Defines the different modes of Probes
type Mode string

const (
	ModeSot        Mode = "SOT"
	ModeEot        Mode = "EOT"
	ModeEdge       Mode = "Edge"
	ModeContinuous Mode = "Continuous"
	ModeOnChaos    Mode = "OnChaos"
)

var AllMode = []Mode{
	ModeSot,
	ModeEot,
	ModeEdge,
	ModeContinuous,
	ModeOnChaos,
}

func (e Mode) IsValid() bool {
	switch e {
	case ModeSot, ModeEot, ModeEdge, ModeContinuous, ModeOnChaos:
		return true
	}
	return false
}

func (e Mode) String() string {
	return string(e)
}

func (e *Mode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Mode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Mode", str)
	}
	return nil
}

func (e Mode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Defines the different statuses of Probes
type ProbeStatus string

const (
	ProbeStatusRunning   ProbeStatus = "Running"
	ProbeStatusCompleted ProbeStatus = "Completed"
	ProbeStatusStopped   ProbeStatus = "Stopped"
	ProbeStatusError     ProbeStatus = "Error"
	ProbeStatusQueued    ProbeStatus = "Queued"
	ProbeStatusNa        ProbeStatus = "NA"
)

var AllProbeStatus = []ProbeStatus{
	ProbeStatusRunning,
	ProbeStatusCompleted,
	ProbeStatusStopped,
	ProbeStatusError,
	ProbeStatusQueued,
	ProbeStatusNa,
}

func (e ProbeStatus) IsValid() bool {
	switch e {
	case ProbeStatusRunning, ProbeStatusCompleted, ProbeStatusStopped, ProbeStatusError, ProbeStatusQueued, ProbeStatusNa:
		return true
	}
	return false
}

func (e ProbeStatus) String() string {
	return string(e)
}

func (e *ProbeStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProbeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProbeStatus", str)
	}
	return nil
}

func (e ProbeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Defines the different types of Probes
type ProbeType string

const (
	ProbeTypeHTTPProbe ProbeType = "httpProbe"
	ProbeTypeCmdProbe  ProbeType = "cmdProbe"
	ProbeTypePromProbe ProbeType = "promProbe"
	ProbeTypeK8sProbe  ProbeType = "k8sProbe"
)

var AllProbeType = []ProbeType{
	ProbeTypeHTTPProbe,
	ProbeTypeCmdProbe,
	ProbeTypePromProbe,
	ProbeTypeK8sProbe,
}

func (e ProbeType) IsValid() bool {
	switch e {
	case ProbeTypeHTTPProbe, ProbeTypeCmdProbe, ProbeTypePromProbe, ProbeTypeK8sProbe:
		return true
	}
	return false
}

func (e ProbeType) String() string {
	return string(e)
}

func (e *ProbeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProbeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProbeType", str)
	}
	return nil
}

func (e ProbeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Defines the older different statuses of Probes
type ProbeVerdict string

const (
	ProbeVerdictPassed  ProbeVerdict = "Passed"
	ProbeVerdictFailed  ProbeVerdict = "Failed"
	ProbeVerdictNa      ProbeVerdict = "NA"
	ProbeVerdictAwaited ProbeVerdict = "Awaited"
)

var AllProbeVerdict = []ProbeVerdict{
	ProbeVerdictPassed,
	ProbeVerdictFailed,
	ProbeVerdictNa,
	ProbeVerdictAwaited,
}

func (e ProbeVerdict) IsValid() bool {
	switch e {
	case ProbeVerdictPassed, ProbeVerdictFailed, ProbeVerdictNa, ProbeVerdictAwaited:
		return true
	}
	return false
}

func (e ProbeVerdict) String() string {
	return string(e)
}

func (e *ProbeVerdict) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProbeVerdict(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProbeVerdict", str)
	}
	return nil
}

func (e ProbeVerdict) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScheduleType string

const (
	ScheduleTypeCron    ScheduleType = "CRON"
	ScheduleTypeNonCron ScheduleType = "NON_CRON"
	ScheduleTypeAll     ScheduleType = "ALL"
)

var AllScheduleType = []ScheduleType{
	ScheduleTypeCron,
	ScheduleTypeNonCron,
	ScheduleTypeAll,
}

func (e ScheduleType) IsValid() bool {
	switch e {
	case ScheduleTypeCron, ScheduleTypeNonCron, ScheduleTypeAll:
		return true
	}
	return false
}

func (e ScheduleType) String() string {
	return string(e)
}

func (e *ScheduleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScheduleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScheduleType", str)
	}
	return nil
}

func (e ScheduleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UpdateStatus represents if infra needs to be updated
type UpdateStatus string

const (
	UpdateStatusAvailable   UpdateStatus = "AVAILABLE"
	UpdateStatusMandatory   UpdateStatus = "MANDATORY"
	UpdateStatusNotRequired UpdateStatus = "NOT_REQUIRED"
)

var AllUpdateStatus = []UpdateStatus{
	UpdateStatusAvailable,
	UpdateStatusMandatory,
	UpdateStatusNotRequired,
}

func (e UpdateStatus) IsValid() bool {
	switch e {
	case UpdateStatusAvailable, UpdateStatusMandatory, UpdateStatusNotRequired:
		return true
	}
	return false
}

func (e UpdateStatus) String() string {
	return string(e)
}

func (e *UpdateStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateStatus", str)
	}
	return nil
}

func (e UpdateStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
