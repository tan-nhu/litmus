// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	Authorized func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	ActionPayload struct {
		ExternalData func(childComplexity int) int
		K8sManifest  func(childComplexity int) int
		Namespace    func(childComplexity int) int
		RequestID    func(childComplexity int) int
		RequestType  func(childComplexity int) int
		Username     func(childComplexity int) int
	}

	Annotation struct {
		Categories       func(childComplexity int) int
		ChartDescription func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Repository       func(childComplexity int) int
		Support          func(childComplexity int) int
		Vendor           func(childComplexity int) int
	}

	ChaosExperimentResponse struct {
		CronSyntax            func(childComplexity int) int
		ExperimentDescription func(childComplexity int) int
		ExperimentID          func(childComplexity int) int
		ExperimentName        func(childComplexity int) int
		IsCustomExperiment    func(childComplexity int) int
		ProjectID             func(childComplexity int) int
		Tags                  func(childComplexity int) int
	}

	ChaosHub struct {
		AuthType      func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		CreatedBy     func(childComplexity int) int
		Description   func(childComplexity int) int
		HubType       func(childComplexity int) int
		ID            func(childComplexity int) int
		IsDefault     func(childComplexity int) int
		IsPrivate     func(childComplexity int) int
		IsRemoved     func(childComplexity int) int
		LastSyncedAt  func(childComplexity int) int
		Name          func(childComplexity int) int
		Password      func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		RepoBranch    func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		Tags          func(childComplexity int) int
		Token         func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UpdatedBy     func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	ChaosHubStatus struct {
		AuthType         func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		CreatedBy        func(childComplexity int) int
		Description      func(childComplexity int) int
		HubType          func(childComplexity int) int
		ID               func(childComplexity int) int
		IsAvailable      func(childComplexity int) int
		IsDefault        func(childComplexity int) int
		IsPrivate        func(childComplexity int) int
		IsRemoved        func(childComplexity int) int
		LastSyncedAt     func(childComplexity int) int
		Name             func(childComplexity int) int
		Password         func(childComplexity int) int
		RepoBranch       func(childComplexity int) int
		RepoURL          func(childComplexity int) int
		SSHPrivateKey    func(childComplexity int) int
		SSHPublicKey     func(childComplexity int) int
		Tags             func(childComplexity int) int
		Token            func(childComplexity int) int
		TotalExperiments func(childComplexity int) int
		TotalFaults      func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		UpdatedBy        func(childComplexity int) int
		UserName         func(childComplexity int) int
	}

	Chart struct {
		APIVersion  func(childComplexity int) int
		Kind        func(childComplexity int) int
		Metadata    func(childComplexity int) int
		PackageInfo func(childComplexity int) int
		Spec        func(childComplexity int) int
	}

	ConfirmInfraRegistrationResponse struct {
		InfraID          func(childComplexity int) int
		IsInfraConfirmed func(childComplexity int) int
		NewAccessKey     func(childComplexity int) int
	}

	Environment struct {
		CreatedAt     func(childComplexity int) int
		CreatedBy     func(childComplexity int) int
		Description   func(childComplexity int) int
		EnvironmentID func(childComplexity int) int
		InfraIDs      func(childComplexity int) int
		IsRemoved     func(childComplexity int) int
		Name          func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		Tags          func(childComplexity int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UpdatedBy     func(childComplexity int) int
	}

	Experiment struct {
		CreatedAt                  func(childComplexity int) int
		CreatedBy                  func(childComplexity int) int
		CronSyntax                 func(childComplexity int) int
		Description                func(childComplexity int) int
		ExperimentID               func(childComplexity int) int
		ExperimentManifest         func(childComplexity int) int
		ExperimentType             func(childComplexity int) int
		Infra                      func(childComplexity int) int
		IsCustomExperiment         func(childComplexity int) int
		IsRemoved                  func(childComplexity int) int
		Name                       func(childComplexity int) int
		ProjectID                  func(childComplexity int) int
		RecentExperimentRunDetails func(childComplexity int) int
		Tags                       func(childComplexity int) int
		UpdatedAt                  func(childComplexity int) int
		UpdatedBy                  func(childComplexity int) int
		Weightages                 func(childComplexity int) int
	}

	ExperimentDetails struct {
		EngineDetails     func(childComplexity int) int
		ExperimentDetails func(childComplexity int) int
	}

	ExperimentRun struct {
		CreatedAt          func(childComplexity int) int
		CreatedBy          func(childComplexity int) int
		ExecutionData      func(childComplexity int) int
		ExperimentID       func(childComplexity int) int
		ExperimentManifest func(childComplexity int) int
		ExperimentName     func(childComplexity int) int
		ExperimentRunID    func(childComplexity int) int
		ExperimentType     func(childComplexity int) int
		FaultsAwaited      func(childComplexity int) int
		FaultsFailed       func(childComplexity int) int
		FaultsNa           func(childComplexity int) int
		FaultsPassed       func(childComplexity int) int
		FaultsStopped      func(childComplexity int) int
		Infra              func(childComplexity int) int
		IsRemoved          func(childComplexity int) int
		Phase              func(childComplexity int) int
		ProjectID          func(childComplexity int) int
		ResiliencyScore    func(childComplexity int) int
		TotalFaults        func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
		UpdatedBy          func(childComplexity int) int
		Weightages         func(childComplexity int) int
	}

	Experiments struct {
		Csv  func(childComplexity int) int
		Desc func(childComplexity int) int
		Name func(childComplexity int) int
	}

	FaultDetails struct {
		Csv    func(childComplexity int) int
		Engine func(childComplexity int) int
		Fault  func(childComplexity int) int
	}

	FaultList struct {
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Name        func(childComplexity int) int
		Plan        func(childComplexity int) int
	}

	GetChaosHubStatsResponse struct {
		TotalChaosHubs func(childComplexity int) int
	}

	GetExperimentResponse struct {
		AverageResiliencyScore func(childComplexity int) int
		ExperimentDetails      func(childComplexity int) int
	}

	GetExperimentRunStatsResponse struct {
		TotalCompletedExperimentRuns  func(childComplexity int) int
		TotalErroredExperimentRuns    func(childComplexity int) int
		TotalExperimentRuns           func(childComplexity int) int
		TotalRunningExperimentRuns    func(childComplexity int) int
		TotalStoppedExperimentRuns    func(childComplexity int) int
		TotalTerminatedExperimentRuns func(childComplexity int) int
	}

	GetExperimentStatsResponse struct {
		TotalExpCategorizedByResiliencyScore func(childComplexity int) int
		TotalExperiments                     func(childComplexity int) int
	}

	GetInfraStatsResponse struct {
		TotalActiveInfrastructure        func(childComplexity int) int
		TotalConfirmedInfrastructure     func(childComplexity int) int
		TotalInactiveInfrastructures     func(childComplexity int) int
		TotalInfrastructures             func(childComplexity int) int
		TotalNonConfirmedInfrastructures func(childComplexity int) int
	}

	GitConfigResponse struct {
		AuthType      func(childComplexity int) int
		Branch        func(childComplexity int) int
		Enabled       func(childComplexity int) int
		Password      func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		Token         func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	ImageRegistry struct {
		EnableRegistry    func(childComplexity int) int
		ImageRegistryName func(childComplexity int) int
		ImageRegistryType func(childComplexity int) int
		ImageRepoName     func(childComplexity int) int
		IsDefault         func(childComplexity int) int
		SecretName        func(childComplexity int) int
		SecretNamespace   func(childComplexity int) int
	}

	ImageRegistryResponse struct {
		CreatedAt         func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		ImageRegistryID   func(childComplexity int) int
		ImageRegistryInfo func(childComplexity int) int
		IsDefault         func(childComplexity int) int
		IsRemoved         func(childComplexity int) int
		ProjectID         func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		UpdatedBy         func(childComplexity int) int
	}

	Infra struct {
		CreatedAt               func(childComplexity int) int
		CreatedBy               func(childComplexity int) int
		Description             func(childComplexity int) int
		EnvironmentID           func(childComplexity int) int
		InfraID                 func(childComplexity int) int
		InfraNamespace          func(childComplexity int) int
		InfraNsExists           func(childComplexity int) int
		InfraSaExists           func(childComplexity int) int
		InfraScope              func(childComplexity int) int
		InfraType               func(childComplexity int) int
		IsActive                func(childComplexity int) int
		IsInfraConfirmed        func(childComplexity int) int
		IsRemoved               func(childComplexity int) int
		LastExperimentTimestamp func(childComplexity int) int
		Name                    func(childComplexity int) int
		NoOfExperimentRuns      func(childComplexity int) int
		NoOfExperiments         func(childComplexity int) int
		PlatformName            func(childComplexity int) int
		ProjectID               func(childComplexity int) int
		ServiceAccount          func(childComplexity int) int
		StartTime               func(childComplexity int) int
		Tags                    func(childComplexity int) int
		Token                   func(childComplexity int) int
		UpdateStatus            func(childComplexity int) int
		UpdatedAt               func(childComplexity int) int
		UpdatedBy               func(childComplexity int) int
		Version                 func(childComplexity int) int
	}

	InfraActionResponse struct {
		Action    func(childComplexity int) int
		ProjectID func(childComplexity int) int
	}

	InfraEventResponse struct {
		Description func(childComplexity int) int
		EventID     func(childComplexity int) int
		EventName   func(childComplexity int) int
		EventType   func(childComplexity int) int
		Infra       func(childComplexity int) int
	}

	InfraVersionDetails struct {
		CompatibleVersions func(childComplexity int) int
		LatestVersion      func(childComplexity int) int
	}

	KubeObject struct {
		Data      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	KubeObjectResponse struct {
		InfraID func(childComplexity int) int
		KubeObj func(childComplexity int) int
	}

	Link struct {
		Name func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	ListEnvironmentResponse struct {
		Environments          func(childComplexity int) int
		TotalNoOfEnvironments func(childComplexity int) int
	}

	ListExperimentResponse struct {
		Experiments          func(childComplexity int) int
		TotalNoOfExperiments func(childComplexity int) int
	}

	ListExperimentRunResponse struct {
		ExperimentRuns          func(childComplexity int) int
		TotalNoOfExperimentRuns func(childComplexity int) int
	}

	ListInfraResponse struct {
		Infras          func(childComplexity int) int
		TotalNoOfInfras func(childComplexity int) int
	}

	Maintainer struct {
		Email func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	Metadata struct {
		Annotations func(childComplexity int) int
		Name        func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	Mutation struct {
		AddChaosHub              func(childComplexity int, projectID string, request model.CreateChaosHubRequest) int
		AddRemoteChaosHub        func(childComplexity int, projectID string, request model.CreateRemoteChaosHub) int
		ChaosExperimentRun       func(childComplexity int, request model.ExperimentRunRequest) int
		ConfirmInfraRegistration func(childComplexity int, request model.InfraIdentity) int
		CreateChaosExperiment    func(childComplexity int, request model.ChaosExperimentRequest, projectID string) int
		CreateEnvironment        func(childComplexity int, projectID string, request *model.CreateEnvironmentRequest) int
		CreateImageRegistry      func(childComplexity int, projectID string, imageRegistryInfo model.ImageRegistryInput) int
		DeleteChaosExperiment    func(childComplexity int, experimentID string, experimentRunID *string, projectID string) int
		DeleteChaosHub           func(childComplexity int, projectID string, hubID string) int
		DeleteEnvironment        func(childComplexity int, projectID string, environmentID string) int
		DeleteImageRegistry      func(childComplexity int, imageRegistryID string, projectID string) int
		DeleteInfra              func(childComplexity int, projectID string, infraID string) int
		DisableGitOps            func(childComplexity int, projectID string) int
		EnableGitOps             func(childComplexity int, configurations model.GitConfig) int
		GenerateSSHKey           func(childComplexity int) int
		GetManifestWithInfraID   func(childComplexity int, projectID string, infraID string, accessKey string) int
		GitopsNotifier           func(childComplexity int, clusterInfo model.InfraIdentity, experimentID string) int
		KubeObj                  func(childComplexity int, request model.KubeObjectData) int
		PodLog                   func(childComplexity int, request model.PodLog) int
		RegisterInfra            func(childComplexity int, projectID string, request model.RegisterInfraRequest) int
		RunChaosExperiment       func(childComplexity int, experimentID string, projectID string) int
		SaveChaosExperiment      func(childComplexity int, request model.SaveChaosExperimentRequest, projectID string) int
		SaveChaosHub             func(childComplexity int, projectID string, request model.CreateChaosHubRequest) int
		SyncChaosHub             func(childComplexity int, id string, projectID string) int
		UpdateChaosExperiment    func(childComplexity int, request *model.ChaosExperimentRequest, projectID string) int
		UpdateChaosHub           func(childComplexity int, projectID string, request model.UpdateChaosHubRequest) int
		UpdateEnvironment        func(childComplexity int, projectID string, request *model.UpdateEnvironmentRequest) int
		UpdateGitOps             func(childComplexity int, configurations model.GitConfig) int
		UpdateImageRegistry      func(childComplexity int, imageRegistryID string, projectID string, imageRegistryInfo model.ImageRegistryInput) int
	}

	ObjectData struct {
		Labels func(childComplexity int) int
		Name   func(childComplexity int) int
	}

	PackageInformation struct {
		Experiments func(childComplexity int) int
		PackageName func(childComplexity int) int
	}

	PodLogResponse struct {
		ExperimentRunID func(childComplexity int) int
		Log             func(childComplexity int) int
		PodName         func(childComplexity int) int
		PodType         func(childComplexity int) int
	}

	PredefinedExperimentList struct {
		ExperimentCsv      func(childComplexity int) int
		ExperimentManifest func(childComplexity int) int
		ExperimentName     func(childComplexity int) int
	}

	Provider struct {
		Name func(childComplexity int) int
	}

	Query struct {
		GetChaosFault             func(childComplexity int, projectID string, request model.ExperimentRequest) int
		GetChaosHub               func(childComplexity int, projectID string, chaosHubID string) int
		GetChaosHubStats          func(childComplexity int, projectID string) int
		GetEnvironment            func(childComplexity int, projectID string, environmentID string) int
		GetExperiment             func(childComplexity int, projectID string, experimentID string) int
		GetExperimentRun          func(childComplexity int, projectID string, experimentRunID string) int
		GetExperimentRunStats     func(childComplexity int, projectID string) int
		GetExperimentStats        func(childComplexity int, projectID string) int
		GetGitOpsDetails          func(childComplexity int, projectID string) int
		GetImageRegistry          func(childComplexity int, imageRegistryID string, projectID string) int
		GetInfra                  func(childComplexity int, projectID string, infraID string) int
		GetInfraDetails           func(childComplexity int, infraID string, projectID string) int
		GetInfraManifest          func(childComplexity int, infraID string, upgrade bool, projectID string) int
		GetInfraStats             func(childComplexity int, projectID string) int
		GetPredefinedExperiment   func(childComplexity int, hubID string, experimentName []string, projectID string) int
		GetServerVersion          func(childComplexity int) int
		GetVersionDetails         func(childComplexity int, projectID string) int
		ListChaosFaults           func(childComplexity int, hubID string, projectID string) int
		ListChaosHub              func(childComplexity int, projectID string, request *model.ListChaosHubRequest) int
		ListEnvironments          func(childComplexity int, projectID string, request *model.ListEnvironmentRequest) int
		ListExperiment            func(childComplexity int, projectID string, request model.ListExperimentRequest) int
		ListExperimentRun         func(childComplexity int, projectID string, request model.ListExperimentRunRequest) int
		ListImageRegistry         func(childComplexity int, projectID string) int
		ListInfras                func(childComplexity int, projectID string, request *model.ListInfraRequest) int
		ListPredefinedExperiments func(childComplexity int, hubID string, projectID string) int
	}

	RecentExperimentRun struct {
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		ExperimentRunID func(childComplexity int) int
		Phase           func(childComplexity int) int
		ResiliencyScore func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
	}

	RegisterInfraResponse struct {
		InfraID  func(childComplexity int) int
		Manifest func(childComplexity int) int
		Name     func(childComplexity int) int
		Token    func(childComplexity int) int
	}

	ResilienceScoreCategory struct {
		Count func(childComplexity int) int
		ID    func(childComplexity int) int
	}

	RunChaosExperimentResponse struct {
		NotifyID func(childComplexity int) int
	}

	SSHKey struct {
		PrivateKey func(childComplexity int) int
		PublicKey  func(childComplexity int) int
	}

	ServerVersionResponse struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Spec struct {
		CategoryDescription func(childComplexity int) int
		ChaosExpCRDLink     func(childComplexity int) int
		ChaosType           func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		Experiments         func(childComplexity int) int
		Faults              func(childComplexity int) int
		Keywords            func(childComplexity int) int
		Links               func(childComplexity int) int
		Maintainers         func(childComplexity int) int
		Maturity            func(childComplexity int) int
		MinKubeVersion      func(childComplexity int) int
		Platforms           func(childComplexity int) int
		Provider            func(childComplexity int) int
	}

	StopExperimentRunsRequest struct {
		ExperimentID    func(childComplexity int) int
		ExperimentRunID func(childComplexity int) int
		ProjectID       func(childComplexity int) int
	}

	Subscription struct {
		GetInfraEvents func(childComplexity int, projectID string) int
		GetKubeObject  func(childComplexity int, request model.KubeObjectRequest) int
		GetPodLog      func(childComplexity int, request model.PodLogRequest) int
		InfraConnect   func(childComplexity int, request model.InfraIdentity) int
	}

	UserDetails struct {
		Email    func(childComplexity int) int
		UserID   func(childComplexity int) int
		Username func(childComplexity int) int
	}

	Weightages struct {
		FaultName func(childComplexity int) int
		Weightage func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateChaosExperiment(ctx context.Context, request model.ChaosExperimentRequest, projectID string) (*model.ChaosExperimentResponse, error)
	SaveChaosExperiment(ctx context.Context, request model.SaveChaosExperimentRequest, projectID string) (string, error)
	RunChaosExperiment(ctx context.Context, experimentID string, projectID string) (*model.RunChaosExperimentResponse, error)
	UpdateChaosExperiment(ctx context.Context, request *model.ChaosExperimentRequest, projectID string) (*model.ChaosExperimentResponse, error)
	DeleteChaosExperiment(ctx context.Context, experimentID string, experimentRunID *string, projectID string) (bool, error)
	ChaosExperimentRun(ctx context.Context, request model.ExperimentRunRequest) (string, error)
	RegisterInfra(ctx context.Context, projectID string, request model.RegisterInfraRequest) (*model.RegisterInfraResponse, error)
	ConfirmInfraRegistration(ctx context.Context, request model.InfraIdentity) (*model.ConfirmInfraRegistrationResponse, error)
	DeleteInfra(ctx context.Context, projectID string, infraID string) (string, error)
	GetManifestWithInfraID(ctx context.Context, projectID string, infraID string, accessKey string) (string, error)
	PodLog(ctx context.Context, request model.PodLog) (string, error)
	KubeObj(ctx context.Context, request model.KubeObjectData) (string, error)
	AddChaosHub(ctx context.Context, projectID string, request model.CreateChaosHubRequest) (*model.ChaosHub, error)
	AddRemoteChaosHub(ctx context.Context, projectID string, request model.CreateRemoteChaosHub) (*model.ChaosHub, error)
	SaveChaosHub(ctx context.Context, projectID string, request model.CreateChaosHubRequest) (*model.ChaosHub, error)
	SyncChaosHub(ctx context.Context, id string, projectID string) (string, error)
	GenerateSSHKey(ctx context.Context) (*model.SSHKey, error)
	UpdateChaosHub(ctx context.Context, projectID string, request model.UpdateChaosHubRequest) (*model.ChaosHub, error)
	DeleteChaosHub(ctx context.Context, projectID string, hubID string) (bool, error)
	CreateEnvironment(ctx context.Context, projectID string, request *model.CreateEnvironmentRequest) (*model.Environment, error)
	UpdateEnvironment(ctx context.Context, projectID string, request *model.UpdateEnvironmentRequest) (string, error)
	DeleteEnvironment(ctx context.Context, projectID string, environmentID string) (string, error)
	GitopsNotifier(ctx context.Context, clusterInfo model.InfraIdentity, experimentID string) (string, error)
	EnableGitOps(ctx context.Context, configurations model.GitConfig) (bool, error)
	DisableGitOps(ctx context.Context, projectID string) (bool, error)
	UpdateGitOps(ctx context.Context, configurations model.GitConfig) (bool, error)
	CreateImageRegistry(ctx context.Context, projectID string, imageRegistryInfo model.ImageRegistryInput) (*model.ImageRegistryResponse, error)
	UpdateImageRegistry(ctx context.Context, imageRegistryID string, projectID string, imageRegistryInfo model.ImageRegistryInput) (*model.ImageRegistryResponse, error)
	DeleteImageRegistry(ctx context.Context, imageRegistryID string, projectID string) (string, error)
}
type QueryResolver interface {
	GetExperimentRun(ctx context.Context, projectID string, experimentRunID string) (*model.ExperimentRun, error)
	ListExperimentRun(ctx context.Context, projectID string, request model.ListExperimentRunRequest) (*model.ListExperimentRunResponse, error)
	GetExperiment(ctx context.Context, projectID string, experimentID string) (*model.GetExperimentResponse, error)
	ListExperiment(ctx context.Context, projectID string, request model.ListExperimentRequest) (*model.ListExperimentResponse, error)
	GetExperimentRunStats(ctx context.Context, projectID string) (*model.GetExperimentRunStatsResponse, error)
	GetExperimentStats(ctx context.Context, projectID string) (*model.GetExperimentStatsResponse, error)
	GetInfra(ctx context.Context, projectID string, infraID string) (*model.Infra, error)
	ListInfras(ctx context.Context, projectID string, request *model.ListInfraRequest) (*model.ListInfraResponse, error)
	GetInfraDetails(ctx context.Context, infraID string, projectID string) (*model.Infra, error)
	GetInfraManifest(ctx context.Context, infraID string, upgrade bool, projectID string) (string, error)
	GetInfraStats(ctx context.Context, projectID string) (*model.GetInfraStatsResponse, error)
	GetVersionDetails(ctx context.Context, projectID string) (*model.InfraVersionDetails, error)
	GetServerVersion(ctx context.Context) (*model.ServerVersionResponse, error)
	ListChaosFaults(ctx context.Context, hubID string, projectID string) ([]*model.Chart, error)
	GetChaosFault(ctx context.Context, projectID string, request model.ExperimentRequest) (*model.FaultDetails, error)
	ListChaosHub(ctx context.Context, projectID string, request *model.ListChaosHubRequest) ([]*model.ChaosHubStatus, error)
	GetChaosHub(ctx context.Context, projectID string, chaosHubID string) (*model.ChaosHubStatus, error)
	ListPredefinedExperiments(ctx context.Context, hubID string, projectID string) ([]*model.PredefinedExperimentList, error)
	GetPredefinedExperiment(ctx context.Context, hubID string, experimentName []string, projectID string) ([]*model.PredefinedExperimentList, error)
	GetChaosHubStats(ctx context.Context, projectID string) (*model.GetChaosHubStatsResponse, error)
	GetEnvironment(ctx context.Context, projectID string, environmentID string) (*model.Environment, error)
	ListEnvironments(ctx context.Context, projectID string, request *model.ListEnvironmentRequest) (*model.ListEnvironmentResponse, error)
	GetGitOpsDetails(ctx context.Context, projectID string) (*model.GitConfigResponse, error)
	ListImageRegistry(ctx context.Context, projectID string) ([]*model.ImageRegistryResponse, error)
	GetImageRegistry(ctx context.Context, imageRegistryID string, projectID string) (*model.ImageRegistryResponse, error)
}
type SubscriptionResolver interface {
	GetInfraEvents(ctx context.Context, projectID string) (<-chan *model.InfraEventResponse, error)
	InfraConnect(ctx context.Context, request model.InfraIdentity) (<-chan *model.InfraActionResponse, error)
	GetPodLog(ctx context.Context, request model.PodLogRequest) (<-chan *model.PodLogResponse, error)
	GetKubeObject(ctx context.Context, request model.KubeObjectRequest) (<-chan *model.KubeObjectResponse, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ActionPayload.externalData":
		if e.complexity.ActionPayload.ExternalData == nil {
			break
		}

		return e.complexity.ActionPayload.ExternalData(childComplexity), true

	case "ActionPayload.k8sManifest":
		if e.complexity.ActionPayload.K8sManifest == nil {
			break
		}

		return e.complexity.ActionPayload.K8sManifest(childComplexity), true

	case "ActionPayload.namespace":
		if e.complexity.ActionPayload.Namespace == nil {
			break
		}

		return e.complexity.ActionPayload.Namespace(childComplexity), true

	case "ActionPayload.requestID":
		if e.complexity.ActionPayload.RequestID == nil {
			break
		}

		return e.complexity.ActionPayload.RequestID(childComplexity), true

	case "ActionPayload.requestType":
		if e.complexity.ActionPayload.RequestType == nil {
			break
		}

		return e.complexity.ActionPayload.RequestType(childComplexity), true

	case "ActionPayload.username":
		if e.complexity.ActionPayload.Username == nil {
			break
		}

		return e.complexity.ActionPayload.Username(childComplexity), true

	case "Annotation.categories":
		if e.complexity.Annotation.Categories == nil {
			break
		}

		return e.complexity.Annotation.Categories(childComplexity), true

	case "Annotation.chartDescription":
		if e.complexity.Annotation.ChartDescription == nil {
			break
		}

		return e.complexity.Annotation.ChartDescription(childComplexity), true

	case "Annotation.createdAt":
		if e.complexity.Annotation.CreatedAt == nil {
			break
		}

		return e.complexity.Annotation.CreatedAt(childComplexity), true

	case "Annotation.repository":
		if e.complexity.Annotation.Repository == nil {
			break
		}

		return e.complexity.Annotation.Repository(childComplexity), true

	case "Annotation.support":
		if e.complexity.Annotation.Support == nil {
			break
		}

		return e.complexity.Annotation.Support(childComplexity), true

	case "Annotation.vendor":
		if e.complexity.Annotation.Vendor == nil {
			break
		}

		return e.complexity.Annotation.Vendor(childComplexity), true

	case "ChaosExperimentResponse.cronSyntax":
		if e.complexity.ChaosExperimentResponse.CronSyntax == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.CronSyntax(childComplexity), true

	case "ChaosExperimentResponse.experimentDescription":
		if e.complexity.ChaosExperimentResponse.ExperimentDescription == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.ExperimentDescription(childComplexity), true

	case "ChaosExperimentResponse.experimentID":
		if e.complexity.ChaosExperimentResponse.ExperimentID == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.ExperimentID(childComplexity), true

	case "ChaosExperimentResponse.experimentName":
		if e.complexity.ChaosExperimentResponse.ExperimentName == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.ExperimentName(childComplexity), true

	case "ChaosExperimentResponse.isCustomExperiment":
		if e.complexity.ChaosExperimentResponse.IsCustomExperiment == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.IsCustomExperiment(childComplexity), true

	case "ChaosExperimentResponse.projectID":
		if e.complexity.ChaosExperimentResponse.ProjectID == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.ProjectID(childComplexity), true

	case "ChaosExperimentResponse.tags":
		if e.complexity.ChaosExperimentResponse.Tags == nil {
			break
		}

		return e.complexity.ChaosExperimentResponse.Tags(childComplexity), true

	case "ChaosHub.authType":
		if e.complexity.ChaosHub.AuthType == nil {
			break
		}

		return e.complexity.ChaosHub.AuthType(childComplexity), true

	case "ChaosHub.createdAt":
		if e.complexity.ChaosHub.CreatedAt == nil {
			break
		}

		return e.complexity.ChaosHub.CreatedAt(childComplexity), true

	case "ChaosHub.createdBy":
		if e.complexity.ChaosHub.CreatedBy == nil {
			break
		}

		return e.complexity.ChaosHub.CreatedBy(childComplexity), true

	case "ChaosHub.description":
		if e.complexity.ChaosHub.Description == nil {
			break
		}

		return e.complexity.ChaosHub.Description(childComplexity), true

	case "ChaosHub.hubType":
		if e.complexity.ChaosHub.HubType == nil {
			break
		}

		return e.complexity.ChaosHub.HubType(childComplexity), true

	case "ChaosHub.id":
		if e.complexity.ChaosHub.ID == nil {
			break
		}

		return e.complexity.ChaosHub.ID(childComplexity), true

	case "ChaosHub.isDefault":
		if e.complexity.ChaosHub.IsDefault == nil {
			break
		}

		return e.complexity.ChaosHub.IsDefault(childComplexity), true

	case "ChaosHub.isPrivate":
		if e.complexity.ChaosHub.IsPrivate == nil {
			break
		}

		return e.complexity.ChaosHub.IsPrivate(childComplexity), true

	case "ChaosHub.isRemoved":
		if e.complexity.ChaosHub.IsRemoved == nil {
			break
		}

		return e.complexity.ChaosHub.IsRemoved(childComplexity), true

	case "ChaosHub.lastSyncedAt":
		if e.complexity.ChaosHub.LastSyncedAt == nil {
			break
		}

		return e.complexity.ChaosHub.LastSyncedAt(childComplexity), true

	case "ChaosHub.name":
		if e.complexity.ChaosHub.Name == nil {
			break
		}

		return e.complexity.ChaosHub.Name(childComplexity), true

	case "ChaosHub.password":
		if e.complexity.ChaosHub.Password == nil {
			break
		}

		return e.complexity.ChaosHub.Password(childComplexity), true

	case "ChaosHub.projectID":
		if e.complexity.ChaosHub.ProjectID == nil {
			break
		}

		return e.complexity.ChaosHub.ProjectID(childComplexity), true

	case "ChaosHub.repoBranch":
		if e.complexity.ChaosHub.RepoBranch == nil {
			break
		}

		return e.complexity.ChaosHub.RepoBranch(childComplexity), true

	case "ChaosHub.repoURL":
		if e.complexity.ChaosHub.RepoURL == nil {
			break
		}

		return e.complexity.ChaosHub.RepoURL(childComplexity), true

	case "ChaosHub.sshPrivateKey":
		if e.complexity.ChaosHub.SSHPrivateKey == nil {
			break
		}

		return e.complexity.ChaosHub.SSHPrivateKey(childComplexity), true

	case "ChaosHub.tags":
		if e.complexity.ChaosHub.Tags == nil {
			break
		}

		return e.complexity.ChaosHub.Tags(childComplexity), true

	case "ChaosHub.token":
		if e.complexity.ChaosHub.Token == nil {
			break
		}

		return e.complexity.ChaosHub.Token(childComplexity), true

	case "ChaosHub.updatedAt":
		if e.complexity.ChaosHub.UpdatedAt == nil {
			break
		}

		return e.complexity.ChaosHub.UpdatedAt(childComplexity), true

	case "ChaosHub.updatedBy":
		if e.complexity.ChaosHub.UpdatedBy == nil {
			break
		}

		return e.complexity.ChaosHub.UpdatedBy(childComplexity), true

	case "ChaosHub.userName":
		if e.complexity.ChaosHub.UserName == nil {
			break
		}

		return e.complexity.ChaosHub.UserName(childComplexity), true

	case "ChaosHubStatus.authType":
		if e.complexity.ChaosHubStatus.AuthType == nil {
			break
		}

		return e.complexity.ChaosHubStatus.AuthType(childComplexity), true

	case "ChaosHubStatus.createdAt":
		if e.complexity.ChaosHubStatus.CreatedAt == nil {
			break
		}

		return e.complexity.ChaosHubStatus.CreatedAt(childComplexity), true

	case "ChaosHubStatus.createdBy":
		if e.complexity.ChaosHubStatus.CreatedBy == nil {
			break
		}

		return e.complexity.ChaosHubStatus.CreatedBy(childComplexity), true

	case "ChaosHubStatus.description":
		if e.complexity.ChaosHubStatus.Description == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Description(childComplexity), true

	case "ChaosHubStatus.hubType":
		if e.complexity.ChaosHubStatus.HubType == nil {
			break
		}

		return e.complexity.ChaosHubStatus.HubType(childComplexity), true

	case "ChaosHubStatus.id":
		if e.complexity.ChaosHubStatus.ID == nil {
			break
		}

		return e.complexity.ChaosHubStatus.ID(childComplexity), true

	case "ChaosHubStatus.isAvailable":
		if e.complexity.ChaosHubStatus.IsAvailable == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsAvailable(childComplexity), true

	case "ChaosHubStatus.isDefault":
		if e.complexity.ChaosHubStatus.IsDefault == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsDefault(childComplexity), true

	case "ChaosHubStatus.isPrivate":
		if e.complexity.ChaosHubStatus.IsPrivate == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsPrivate(childComplexity), true

	case "ChaosHubStatus.isRemoved":
		if e.complexity.ChaosHubStatus.IsRemoved == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsRemoved(childComplexity), true

	case "ChaosHubStatus.lastSyncedAt":
		if e.complexity.ChaosHubStatus.LastSyncedAt == nil {
			break
		}

		return e.complexity.ChaosHubStatus.LastSyncedAt(childComplexity), true

	case "ChaosHubStatus.name":
		if e.complexity.ChaosHubStatus.Name == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Name(childComplexity), true

	case "ChaosHubStatus.password":
		if e.complexity.ChaosHubStatus.Password == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Password(childComplexity), true

	case "ChaosHubStatus.repoBranch":
		if e.complexity.ChaosHubStatus.RepoBranch == nil {
			break
		}

		return e.complexity.ChaosHubStatus.RepoBranch(childComplexity), true

	case "ChaosHubStatus.repoURL":
		if e.complexity.ChaosHubStatus.RepoURL == nil {
			break
		}

		return e.complexity.ChaosHubStatus.RepoURL(childComplexity), true

	case "ChaosHubStatus.sshPrivateKey":
		if e.complexity.ChaosHubStatus.SSHPrivateKey == nil {
			break
		}

		return e.complexity.ChaosHubStatus.SSHPrivateKey(childComplexity), true

	case "ChaosHubStatus.sshPublicKey":
		if e.complexity.ChaosHubStatus.SSHPublicKey == nil {
			break
		}

		return e.complexity.ChaosHubStatus.SSHPublicKey(childComplexity), true

	case "ChaosHubStatus.tags":
		if e.complexity.ChaosHubStatus.Tags == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Tags(childComplexity), true

	case "ChaosHubStatus.token":
		if e.complexity.ChaosHubStatus.Token == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Token(childComplexity), true

	case "ChaosHubStatus.totalExperiments":
		if e.complexity.ChaosHubStatus.TotalExperiments == nil {
			break
		}

		return e.complexity.ChaosHubStatus.TotalExperiments(childComplexity), true

	case "ChaosHubStatus.totalFaults":
		if e.complexity.ChaosHubStatus.TotalFaults == nil {
			break
		}

		return e.complexity.ChaosHubStatus.TotalFaults(childComplexity), true

	case "ChaosHubStatus.updatedAt":
		if e.complexity.ChaosHubStatus.UpdatedAt == nil {
			break
		}

		return e.complexity.ChaosHubStatus.UpdatedAt(childComplexity), true

	case "ChaosHubStatus.updatedBy":
		if e.complexity.ChaosHubStatus.UpdatedBy == nil {
			break
		}

		return e.complexity.ChaosHubStatus.UpdatedBy(childComplexity), true

	case "ChaosHubStatus.userName":
		if e.complexity.ChaosHubStatus.UserName == nil {
			break
		}

		return e.complexity.ChaosHubStatus.UserName(childComplexity), true

	case "Chart.apiVersion":
		if e.complexity.Chart.APIVersion == nil {
			break
		}

		return e.complexity.Chart.APIVersion(childComplexity), true

	case "Chart.kind":
		if e.complexity.Chart.Kind == nil {
			break
		}

		return e.complexity.Chart.Kind(childComplexity), true

	case "Chart.metadata":
		if e.complexity.Chart.Metadata == nil {
			break
		}

		return e.complexity.Chart.Metadata(childComplexity), true

	case "Chart.packageInfo":
		if e.complexity.Chart.PackageInfo == nil {
			break
		}

		return e.complexity.Chart.PackageInfo(childComplexity), true

	case "Chart.spec":
		if e.complexity.Chart.Spec == nil {
			break
		}

		return e.complexity.Chart.Spec(childComplexity), true

	case "ConfirmInfraRegistrationResponse.infraID":
		if e.complexity.ConfirmInfraRegistrationResponse.InfraID == nil {
			break
		}

		return e.complexity.ConfirmInfraRegistrationResponse.InfraID(childComplexity), true

	case "ConfirmInfraRegistrationResponse.isInfraConfirmed":
		if e.complexity.ConfirmInfraRegistrationResponse.IsInfraConfirmed == nil {
			break
		}

		return e.complexity.ConfirmInfraRegistrationResponse.IsInfraConfirmed(childComplexity), true

	case "ConfirmInfraRegistrationResponse.newAccessKey":
		if e.complexity.ConfirmInfraRegistrationResponse.NewAccessKey == nil {
			break
		}

		return e.complexity.ConfirmInfraRegistrationResponse.NewAccessKey(childComplexity), true

	case "Environment.createdAt":
		if e.complexity.Environment.CreatedAt == nil {
			break
		}

		return e.complexity.Environment.CreatedAt(childComplexity), true

	case "Environment.createdBy":
		if e.complexity.Environment.CreatedBy == nil {
			break
		}

		return e.complexity.Environment.CreatedBy(childComplexity), true

	case "Environment.description":
		if e.complexity.Environment.Description == nil {
			break
		}

		return e.complexity.Environment.Description(childComplexity), true

	case "Environment.environmentID":
		if e.complexity.Environment.EnvironmentID == nil {
			break
		}

		return e.complexity.Environment.EnvironmentID(childComplexity), true

	case "Environment.infraIDs":
		if e.complexity.Environment.InfraIDs == nil {
			break
		}

		return e.complexity.Environment.InfraIDs(childComplexity), true

	case "Environment.isRemoved":
		if e.complexity.Environment.IsRemoved == nil {
			break
		}

		return e.complexity.Environment.IsRemoved(childComplexity), true

	case "Environment.name":
		if e.complexity.Environment.Name == nil {
			break
		}

		return e.complexity.Environment.Name(childComplexity), true

	case "Environment.projectID":
		if e.complexity.Environment.ProjectID == nil {
			break
		}

		return e.complexity.Environment.ProjectID(childComplexity), true

	case "Environment.tags":
		if e.complexity.Environment.Tags == nil {
			break
		}

		return e.complexity.Environment.Tags(childComplexity), true

	case "Environment.type":
		if e.complexity.Environment.Type == nil {
			break
		}

		return e.complexity.Environment.Type(childComplexity), true

	case "Environment.updatedAt":
		if e.complexity.Environment.UpdatedAt == nil {
			break
		}

		return e.complexity.Environment.UpdatedAt(childComplexity), true

	case "Environment.updatedBy":
		if e.complexity.Environment.UpdatedBy == nil {
			break
		}

		return e.complexity.Environment.UpdatedBy(childComplexity), true

	case "Experiment.createdAt":
		if e.complexity.Experiment.CreatedAt == nil {
			break
		}

		return e.complexity.Experiment.CreatedAt(childComplexity), true

	case "Experiment.createdBy":
		if e.complexity.Experiment.CreatedBy == nil {
			break
		}

		return e.complexity.Experiment.CreatedBy(childComplexity), true

	case "Experiment.cronSyntax":
		if e.complexity.Experiment.CronSyntax == nil {
			break
		}

		return e.complexity.Experiment.CronSyntax(childComplexity), true

	case "Experiment.description":
		if e.complexity.Experiment.Description == nil {
			break
		}

		return e.complexity.Experiment.Description(childComplexity), true

	case "Experiment.experimentID":
		if e.complexity.Experiment.ExperimentID == nil {
			break
		}

		return e.complexity.Experiment.ExperimentID(childComplexity), true

	case "Experiment.experimentManifest":
		if e.complexity.Experiment.ExperimentManifest == nil {
			break
		}

		return e.complexity.Experiment.ExperimentManifest(childComplexity), true

	case "Experiment.experimentType":
		if e.complexity.Experiment.ExperimentType == nil {
			break
		}

		return e.complexity.Experiment.ExperimentType(childComplexity), true

	case "Experiment.infra":
		if e.complexity.Experiment.Infra == nil {
			break
		}

		return e.complexity.Experiment.Infra(childComplexity), true

	case "Experiment.isCustomExperiment":
		if e.complexity.Experiment.IsCustomExperiment == nil {
			break
		}

		return e.complexity.Experiment.IsCustomExperiment(childComplexity), true

	case "Experiment.isRemoved":
		if e.complexity.Experiment.IsRemoved == nil {
			break
		}

		return e.complexity.Experiment.IsRemoved(childComplexity), true

	case "Experiment.name":
		if e.complexity.Experiment.Name == nil {
			break
		}

		return e.complexity.Experiment.Name(childComplexity), true

	case "Experiment.projectID":
		if e.complexity.Experiment.ProjectID == nil {
			break
		}

		return e.complexity.Experiment.ProjectID(childComplexity), true

	case "Experiment.recentExperimentRunDetails":
		if e.complexity.Experiment.RecentExperimentRunDetails == nil {
			break
		}

		return e.complexity.Experiment.RecentExperimentRunDetails(childComplexity), true

	case "Experiment.tags":
		if e.complexity.Experiment.Tags == nil {
			break
		}

		return e.complexity.Experiment.Tags(childComplexity), true

	case "Experiment.updatedAt":
		if e.complexity.Experiment.UpdatedAt == nil {
			break
		}

		return e.complexity.Experiment.UpdatedAt(childComplexity), true

	case "Experiment.updatedBy":
		if e.complexity.Experiment.UpdatedBy == nil {
			break
		}

		return e.complexity.Experiment.UpdatedBy(childComplexity), true

	case "Experiment.weightages":
		if e.complexity.Experiment.Weightages == nil {
			break
		}

		return e.complexity.Experiment.Weightages(childComplexity), true

	case "ExperimentDetails.engineDetails":
		if e.complexity.ExperimentDetails.EngineDetails == nil {
			break
		}

		return e.complexity.ExperimentDetails.EngineDetails(childComplexity), true

	case "ExperimentDetails.experimentDetails":
		if e.complexity.ExperimentDetails.ExperimentDetails == nil {
			break
		}

		return e.complexity.ExperimentDetails.ExperimentDetails(childComplexity), true

	case "ExperimentRun.createdAt":
		if e.complexity.ExperimentRun.CreatedAt == nil {
			break
		}

		return e.complexity.ExperimentRun.CreatedAt(childComplexity), true

	case "ExperimentRun.createdBy":
		if e.complexity.ExperimentRun.CreatedBy == nil {
			break
		}

		return e.complexity.ExperimentRun.CreatedBy(childComplexity), true

	case "ExperimentRun.executionData":
		if e.complexity.ExperimentRun.ExecutionData == nil {
			break
		}

		return e.complexity.ExperimentRun.ExecutionData(childComplexity), true

	case "ExperimentRun.experimentID":
		if e.complexity.ExperimentRun.ExperimentID == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentID(childComplexity), true

	case "ExperimentRun.experimentManifest":
		if e.complexity.ExperimentRun.ExperimentManifest == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentManifest(childComplexity), true

	case "ExperimentRun.experimentName":
		if e.complexity.ExperimentRun.ExperimentName == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentName(childComplexity), true

	case "ExperimentRun.experimentRunID":
		if e.complexity.ExperimentRun.ExperimentRunID == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentRunID(childComplexity), true

	case "ExperimentRun.experimentType":
		if e.complexity.ExperimentRun.ExperimentType == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentType(childComplexity), true

	case "ExperimentRun.faultsAwaited":
		if e.complexity.ExperimentRun.FaultsAwaited == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsAwaited(childComplexity), true

	case "ExperimentRun.faultsFailed":
		if e.complexity.ExperimentRun.FaultsFailed == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsFailed(childComplexity), true

	case "ExperimentRun.faultsNa":
		if e.complexity.ExperimentRun.FaultsNa == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsNa(childComplexity), true

	case "ExperimentRun.faultsPassed":
		if e.complexity.ExperimentRun.FaultsPassed == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsPassed(childComplexity), true

	case "ExperimentRun.faultsStopped":
		if e.complexity.ExperimentRun.FaultsStopped == nil {
			break
		}

		return e.complexity.ExperimentRun.FaultsStopped(childComplexity), true

	case "ExperimentRun.infra":
		if e.complexity.ExperimentRun.Infra == nil {
			break
		}

		return e.complexity.ExperimentRun.Infra(childComplexity), true

	case "ExperimentRun.isRemoved":
		if e.complexity.ExperimentRun.IsRemoved == nil {
			break
		}

		return e.complexity.ExperimentRun.IsRemoved(childComplexity), true

	case "ExperimentRun.phase":
		if e.complexity.ExperimentRun.Phase == nil {
			break
		}

		return e.complexity.ExperimentRun.Phase(childComplexity), true

	case "ExperimentRun.projectID":
		if e.complexity.ExperimentRun.ProjectID == nil {
			break
		}

		return e.complexity.ExperimentRun.ProjectID(childComplexity), true

	case "ExperimentRun.resiliencyScore":
		if e.complexity.ExperimentRun.ResiliencyScore == nil {
			break
		}

		return e.complexity.ExperimentRun.ResiliencyScore(childComplexity), true

	case "ExperimentRun.totalFaults":
		if e.complexity.ExperimentRun.TotalFaults == nil {
			break
		}

		return e.complexity.ExperimentRun.TotalFaults(childComplexity), true

	case "ExperimentRun.updatedAt":
		if e.complexity.ExperimentRun.UpdatedAt == nil {
			break
		}

		return e.complexity.ExperimentRun.UpdatedAt(childComplexity), true

	case "ExperimentRun.updatedBy":
		if e.complexity.ExperimentRun.UpdatedBy == nil {
			break
		}

		return e.complexity.ExperimentRun.UpdatedBy(childComplexity), true

	case "ExperimentRun.weightages":
		if e.complexity.ExperimentRun.Weightages == nil {
			break
		}

		return e.complexity.ExperimentRun.Weightages(childComplexity), true

	case "Experiments.CSV":
		if e.complexity.Experiments.Csv == nil {
			break
		}

		return e.complexity.Experiments.Csv(childComplexity), true

	case "Experiments.desc":
		if e.complexity.Experiments.Desc == nil {
			break
		}

		return e.complexity.Experiments.Desc(childComplexity), true

	case "Experiments.name":
		if e.complexity.Experiments.Name == nil {
			break
		}

		return e.complexity.Experiments.Name(childComplexity), true

	case "FaultDetails.csv":
		if e.complexity.FaultDetails.Csv == nil {
			break
		}

		return e.complexity.FaultDetails.Csv(childComplexity), true

	case "FaultDetails.engine":
		if e.complexity.FaultDetails.Engine == nil {
			break
		}

		return e.complexity.FaultDetails.Engine(childComplexity), true

	case "FaultDetails.fault":
		if e.complexity.FaultDetails.Fault == nil {
			break
		}

		return e.complexity.FaultDetails.Fault(childComplexity), true

	case "FaultList.description":
		if e.complexity.FaultList.Description == nil {
			break
		}

		return e.complexity.FaultList.Description(childComplexity), true

	case "FaultList.displayName":
		if e.complexity.FaultList.DisplayName == nil {
			break
		}

		return e.complexity.FaultList.DisplayName(childComplexity), true

	case "FaultList.name":
		if e.complexity.FaultList.Name == nil {
			break
		}

		return e.complexity.FaultList.Name(childComplexity), true

	case "FaultList.plan":
		if e.complexity.FaultList.Plan == nil {
			break
		}

		return e.complexity.FaultList.Plan(childComplexity), true

	case "GetChaosHubStatsResponse.totalChaosHubs":
		if e.complexity.GetChaosHubStatsResponse.TotalChaosHubs == nil {
			break
		}

		return e.complexity.GetChaosHubStatsResponse.TotalChaosHubs(childComplexity), true

	case "GetExperimentResponse.averageResiliencyScore":
		if e.complexity.GetExperimentResponse.AverageResiliencyScore == nil {
			break
		}

		return e.complexity.GetExperimentResponse.AverageResiliencyScore(childComplexity), true

	case "GetExperimentResponse.experimentDetails":
		if e.complexity.GetExperimentResponse.ExperimentDetails == nil {
			break
		}

		return e.complexity.GetExperimentResponse.ExperimentDetails(childComplexity), true

	case "GetExperimentRunStatsResponse.totalCompletedExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalCompletedExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalCompletedExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalErroredExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalErroredExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalErroredExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalRunningExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalRunningExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalRunningExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalStoppedExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalStoppedExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalStoppedExperimentRuns(childComplexity), true

	case "GetExperimentRunStatsResponse.totalTerminatedExperimentRuns":
		if e.complexity.GetExperimentRunStatsResponse.TotalTerminatedExperimentRuns == nil {
			break
		}

		return e.complexity.GetExperimentRunStatsResponse.TotalTerminatedExperimentRuns(childComplexity), true

	case "GetExperimentStatsResponse.totalExpCategorizedByResiliencyScore":
		if e.complexity.GetExperimentStatsResponse.TotalExpCategorizedByResiliencyScore == nil {
			break
		}

		return e.complexity.GetExperimentStatsResponse.TotalExpCategorizedByResiliencyScore(childComplexity), true

	case "GetExperimentStatsResponse.totalExperiments":
		if e.complexity.GetExperimentStatsResponse.TotalExperiments == nil {
			break
		}

		return e.complexity.GetExperimentStatsResponse.TotalExperiments(childComplexity), true

	case "GetInfraStatsResponse.totalActiveInfrastructure":
		if e.complexity.GetInfraStatsResponse.TotalActiveInfrastructure == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalActiveInfrastructure(childComplexity), true

	case "GetInfraStatsResponse.totalConfirmedInfrastructure":
		if e.complexity.GetInfraStatsResponse.TotalConfirmedInfrastructure == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalConfirmedInfrastructure(childComplexity), true

	case "GetInfraStatsResponse.totalInactiveInfrastructures":
		if e.complexity.GetInfraStatsResponse.TotalInactiveInfrastructures == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalInactiveInfrastructures(childComplexity), true

	case "GetInfraStatsResponse.totalInfrastructures":
		if e.complexity.GetInfraStatsResponse.TotalInfrastructures == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalInfrastructures(childComplexity), true

	case "GetInfraStatsResponse.totalNonConfirmedInfrastructures":
		if e.complexity.GetInfraStatsResponse.TotalNonConfirmedInfrastructures == nil {
			break
		}

		return e.complexity.GetInfraStatsResponse.TotalNonConfirmedInfrastructures(childComplexity), true

	case "GitConfigResponse.authType":
		if e.complexity.GitConfigResponse.AuthType == nil {
			break
		}

		return e.complexity.GitConfigResponse.AuthType(childComplexity), true

	case "GitConfigResponse.branch":
		if e.complexity.GitConfigResponse.Branch == nil {
			break
		}

		return e.complexity.GitConfigResponse.Branch(childComplexity), true

	case "GitConfigResponse.enabled":
		if e.complexity.GitConfigResponse.Enabled == nil {
			break
		}

		return e.complexity.GitConfigResponse.Enabled(childComplexity), true

	case "GitConfigResponse.password":
		if e.complexity.GitConfigResponse.Password == nil {
			break
		}

		return e.complexity.GitConfigResponse.Password(childComplexity), true

	case "GitConfigResponse.projectID":
		if e.complexity.GitConfigResponse.ProjectID == nil {
			break
		}

		return e.complexity.GitConfigResponse.ProjectID(childComplexity), true

	case "GitConfigResponse.repoURL":
		if e.complexity.GitConfigResponse.RepoURL == nil {
			break
		}

		return e.complexity.GitConfigResponse.RepoURL(childComplexity), true

	case "GitConfigResponse.sshPrivateKey":
		if e.complexity.GitConfigResponse.SSHPrivateKey == nil {
			break
		}

		return e.complexity.GitConfigResponse.SSHPrivateKey(childComplexity), true

	case "GitConfigResponse.token":
		if e.complexity.GitConfigResponse.Token == nil {
			break
		}

		return e.complexity.GitConfigResponse.Token(childComplexity), true

	case "GitConfigResponse.userName":
		if e.complexity.GitConfigResponse.UserName == nil {
			break
		}

		return e.complexity.GitConfigResponse.UserName(childComplexity), true

	case "ImageRegistry.enableRegistry":
		if e.complexity.ImageRegistry.EnableRegistry == nil {
			break
		}

		return e.complexity.ImageRegistry.EnableRegistry(childComplexity), true

	case "ImageRegistry.imageRegistryName":
		if e.complexity.ImageRegistry.ImageRegistryName == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRegistryName(childComplexity), true

	case "ImageRegistry.imageRegistryType":
		if e.complexity.ImageRegistry.ImageRegistryType == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRegistryType(childComplexity), true

	case "ImageRegistry.imageRepoName":
		if e.complexity.ImageRegistry.ImageRepoName == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRepoName(childComplexity), true

	case "ImageRegistry.isDefault":
		if e.complexity.ImageRegistry.IsDefault == nil {
			break
		}

		return e.complexity.ImageRegistry.IsDefault(childComplexity), true

	case "ImageRegistry.secretName":
		if e.complexity.ImageRegistry.SecretName == nil {
			break
		}

		return e.complexity.ImageRegistry.SecretName(childComplexity), true

	case "ImageRegistry.secretNamespace":
		if e.complexity.ImageRegistry.SecretNamespace == nil {
			break
		}

		return e.complexity.ImageRegistry.SecretNamespace(childComplexity), true

	case "ImageRegistryResponse.createdAt":
		if e.complexity.ImageRegistryResponse.CreatedAt == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.CreatedAt(childComplexity), true

	case "ImageRegistryResponse.createdBy":
		if e.complexity.ImageRegistryResponse.CreatedBy == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.CreatedBy(childComplexity), true

	case "ImageRegistryResponse.imageRegistryID":
		if e.complexity.ImageRegistryResponse.ImageRegistryID == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ImageRegistryID(childComplexity), true

	case "ImageRegistryResponse.imageRegistryInfo":
		if e.complexity.ImageRegistryResponse.ImageRegistryInfo == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ImageRegistryInfo(childComplexity), true

	case "ImageRegistryResponse.isDefault":
		if e.complexity.ImageRegistryResponse.IsDefault == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.IsDefault(childComplexity), true

	case "ImageRegistryResponse.isRemoved":
		if e.complexity.ImageRegistryResponse.IsRemoved == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.IsRemoved(childComplexity), true

	case "ImageRegistryResponse.projectID":
		if e.complexity.ImageRegistryResponse.ProjectID == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ProjectID(childComplexity), true

	case "ImageRegistryResponse.updatedAt":
		if e.complexity.ImageRegistryResponse.UpdatedAt == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.UpdatedAt(childComplexity), true

	case "ImageRegistryResponse.updatedBy":
		if e.complexity.ImageRegistryResponse.UpdatedBy == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.UpdatedBy(childComplexity), true

	case "Infra.createdAt":
		if e.complexity.Infra.CreatedAt == nil {
			break
		}

		return e.complexity.Infra.CreatedAt(childComplexity), true

	case "Infra.createdBy":
		if e.complexity.Infra.CreatedBy == nil {
			break
		}

		return e.complexity.Infra.CreatedBy(childComplexity), true

	case "Infra.description":
		if e.complexity.Infra.Description == nil {
			break
		}

		return e.complexity.Infra.Description(childComplexity), true

	case "Infra.environmentID":
		if e.complexity.Infra.EnvironmentID == nil {
			break
		}

		return e.complexity.Infra.EnvironmentID(childComplexity), true

	case "Infra.infraID":
		if e.complexity.Infra.InfraID == nil {
			break
		}

		return e.complexity.Infra.InfraID(childComplexity), true

	case "Infra.infraNamespace":
		if e.complexity.Infra.InfraNamespace == nil {
			break
		}

		return e.complexity.Infra.InfraNamespace(childComplexity), true

	case "Infra.infraNsExists":
		if e.complexity.Infra.InfraNsExists == nil {
			break
		}

		return e.complexity.Infra.InfraNsExists(childComplexity), true

	case "Infra.infraSaExists":
		if e.complexity.Infra.InfraSaExists == nil {
			break
		}

		return e.complexity.Infra.InfraSaExists(childComplexity), true

	case "Infra.infraScope":
		if e.complexity.Infra.InfraScope == nil {
			break
		}

		return e.complexity.Infra.InfraScope(childComplexity), true

	case "Infra.infraType":
		if e.complexity.Infra.InfraType == nil {
			break
		}

		return e.complexity.Infra.InfraType(childComplexity), true

	case "Infra.isActive":
		if e.complexity.Infra.IsActive == nil {
			break
		}

		return e.complexity.Infra.IsActive(childComplexity), true

	case "Infra.isInfraConfirmed":
		if e.complexity.Infra.IsInfraConfirmed == nil {
			break
		}

		return e.complexity.Infra.IsInfraConfirmed(childComplexity), true

	case "Infra.isRemoved":
		if e.complexity.Infra.IsRemoved == nil {
			break
		}

		return e.complexity.Infra.IsRemoved(childComplexity), true

	case "Infra.lastExperimentTimestamp":
		if e.complexity.Infra.LastExperimentTimestamp == nil {
			break
		}

		return e.complexity.Infra.LastExperimentTimestamp(childComplexity), true

	case "Infra.name":
		if e.complexity.Infra.Name == nil {
			break
		}

		return e.complexity.Infra.Name(childComplexity), true

	case "Infra.noOfExperimentRuns":
		if e.complexity.Infra.NoOfExperimentRuns == nil {
			break
		}

		return e.complexity.Infra.NoOfExperimentRuns(childComplexity), true

	case "Infra.noOfExperiments":
		if e.complexity.Infra.NoOfExperiments == nil {
			break
		}

		return e.complexity.Infra.NoOfExperiments(childComplexity), true

	case "Infra.platformName":
		if e.complexity.Infra.PlatformName == nil {
			break
		}

		return e.complexity.Infra.PlatformName(childComplexity), true

	case "Infra.projectID":
		if e.complexity.Infra.ProjectID == nil {
			break
		}

		return e.complexity.Infra.ProjectID(childComplexity), true

	case "Infra.serviceAccount":
		if e.complexity.Infra.ServiceAccount == nil {
			break
		}

		return e.complexity.Infra.ServiceAccount(childComplexity), true

	case "Infra.startTime":
		if e.complexity.Infra.StartTime == nil {
			break
		}

		return e.complexity.Infra.StartTime(childComplexity), true

	case "Infra.tags":
		if e.complexity.Infra.Tags == nil {
			break
		}

		return e.complexity.Infra.Tags(childComplexity), true

	case "Infra.token":
		if e.complexity.Infra.Token == nil {
			break
		}

		return e.complexity.Infra.Token(childComplexity), true

	case "Infra.updateStatus":
		if e.complexity.Infra.UpdateStatus == nil {
			break
		}

		return e.complexity.Infra.UpdateStatus(childComplexity), true

	case "Infra.updatedAt":
		if e.complexity.Infra.UpdatedAt == nil {
			break
		}

		return e.complexity.Infra.UpdatedAt(childComplexity), true

	case "Infra.updatedBy":
		if e.complexity.Infra.UpdatedBy == nil {
			break
		}

		return e.complexity.Infra.UpdatedBy(childComplexity), true

	case "Infra.version":
		if e.complexity.Infra.Version == nil {
			break
		}

		return e.complexity.Infra.Version(childComplexity), true

	case "InfraActionResponse.action":
		if e.complexity.InfraActionResponse.Action == nil {
			break
		}

		return e.complexity.InfraActionResponse.Action(childComplexity), true

	case "InfraActionResponse.projectID":
		if e.complexity.InfraActionResponse.ProjectID == nil {
			break
		}

		return e.complexity.InfraActionResponse.ProjectID(childComplexity), true

	case "InfraEventResponse.description":
		if e.complexity.InfraEventResponse.Description == nil {
			break
		}

		return e.complexity.InfraEventResponse.Description(childComplexity), true

	case "InfraEventResponse.eventID":
		if e.complexity.InfraEventResponse.EventID == nil {
			break
		}

		return e.complexity.InfraEventResponse.EventID(childComplexity), true

	case "InfraEventResponse.eventName":
		if e.complexity.InfraEventResponse.EventName == nil {
			break
		}

		return e.complexity.InfraEventResponse.EventName(childComplexity), true

	case "InfraEventResponse.eventType":
		if e.complexity.InfraEventResponse.EventType == nil {
			break
		}

		return e.complexity.InfraEventResponse.EventType(childComplexity), true

	case "InfraEventResponse.infra":
		if e.complexity.InfraEventResponse.Infra == nil {
			break
		}

		return e.complexity.InfraEventResponse.Infra(childComplexity), true

	case "InfraVersionDetails.compatibleVersions":
		if e.complexity.InfraVersionDetails.CompatibleVersions == nil {
			break
		}

		return e.complexity.InfraVersionDetails.CompatibleVersions(childComplexity), true

	case "InfraVersionDetails.latestVersion":
		if e.complexity.InfraVersionDetails.LatestVersion == nil {
			break
		}

		return e.complexity.InfraVersionDetails.LatestVersion(childComplexity), true

	case "KubeObject.data":
		if e.complexity.KubeObject.Data == nil {
			break
		}

		return e.complexity.KubeObject.Data(childComplexity), true

	case "KubeObject.namespace":
		if e.complexity.KubeObject.Namespace == nil {
			break
		}

		return e.complexity.KubeObject.Namespace(childComplexity), true

	case "KubeObjectResponse.infraID":
		if e.complexity.KubeObjectResponse.InfraID == nil {
			break
		}

		return e.complexity.KubeObjectResponse.InfraID(childComplexity), true

	case "KubeObjectResponse.kubeObj":
		if e.complexity.KubeObjectResponse.KubeObj == nil {
			break
		}

		return e.complexity.KubeObjectResponse.KubeObj(childComplexity), true

	case "Link.name":
		if e.complexity.Link.Name == nil {
			break
		}

		return e.complexity.Link.Name(childComplexity), true

	case "Link.url":
		if e.complexity.Link.URL == nil {
			break
		}

		return e.complexity.Link.URL(childComplexity), true

	case "ListEnvironmentResponse.environments":
		if e.complexity.ListEnvironmentResponse.Environments == nil {
			break
		}

		return e.complexity.ListEnvironmentResponse.Environments(childComplexity), true

	case "ListEnvironmentResponse.totalNoOfEnvironments":
		if e.complexity.ListEnvironmentResponse.TotalNoOfEnvironments == nil {
			break
		}

		return e.complexity.ListEnvironmentResponse.TotalNoOfEnvironments(childComplexity), true

	case "ListExperimentResponse.experiments":
		if e.complexity.ListExperimentResponse.Experiments == nil {
			break
		}

		return e.complexity.ListExperimentResponse.Experiments(childComplexity), true

	case "ListExperimentResponse.totalNoOfExperiments":
		if e.complexity.ListExperimentResponse.TotalNoOfExperiments == nil {
			break
		}

		return e.complexity.ListExperimentResponse.TotalNoOfExperiments(childComplexity), true

	case "ListExperimentRunResponse.experimentRuns":
		if e.complexity.ListExperimentRunResponse.ExperimentRuns == nil {
			break
		}

		return e.complexity.ListExperimentRunResponse.ExperimentRuns(childComplexity), true

	case "ListExperimentRunResponse.totalNoOfExperimentRuns":
		if e.complexity.ListExperimentRunResponse.TotalNoOfExperimentRuns == nil {
			break
		}

		return e.complexity.ListExperimentRunResponse.TotalNoOfExperimentRuns(childComplexity), true

	case "ListInfraResponse.infras":
		if e.complexity.ListInfraResponse.Infras == nil {
			break
		}

		return e.complexity.ListInfraResponse.Infras(childComplexity), true

	case "ListInfraResponse.totalNoOfInfras":
		if e.complexity.ListInfraResponse.TotalNoOfInfras == nil {
			break
		}

		return e.complexity.ListInfraResponse.TotalNoOfInfras(childComplexity), true

	case "Maintainer.email":
		if e.complexity.Maintainer.Email == nil {
			break
		}

		return e.complexity.Maintainer.Email(childComplexity), true

	case "Maintainer.name":
		if e.complexity.Maintainer.Name == nil {
			break
		}

		return e.complexity.Maintainer.Name(childComplexity), true

	case "Metadata.annotations":
		if e.complexity.Metadata.Annotations == nil {
			break
		}

		return e.complexity.Metadata.Annotations(childComplexity), true

	case "Metadata.name":
		if e.complexity.Metadata.Name == nil {
			break
		}

		return e.complexity.Metadata.Name(childComplexity), true

	case "Metadata.version":
		if e.complexity.Metadata.Version == nil {
			break
		}

		return e.complexity.Metadata.Version(childComplexity), true

	case "Mutation.addChaosHub":
		if e.complexity.Mutation.AddChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_addChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddChaosHub(childComplexity, args["projectID"].(string), args["request"].(model.CreateChaosHubRequest)), true

	case "Mutation.addRemoteChaosHub":
		if e.complexity.Mutation.AddRemoteChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_addRemoteChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRemoteChaosHub(childComplexity, args["projectID"].(string), args["request"].(model.CreateRemoteChaosHub)), true

	case "Mutation.chaosExperimentRun":
		if e.complexity.Mutation.ChaosExperimentRun == nil {
			break
		}

		args, err := ec.field_Mutation_chaosExperimentRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChaosExperimentRun(childComplexity, args["request"].(model.ExperimentRunRequest)), true

	case "Mutation.confirmInfraRegistration":
		if e.complexity.Mutation.ConfirmInfraRegistration == nil {
			break
		}

		args, err := ec.field_Mutation_confirmInfraRegistration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmInfraRegistration(childComplexity, args["request"].(model.InfraIdentity)), true

	case "Mutation.createChaosExperiment":
		if e.complexity.Mutation.CreateChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_createChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateChaosExperiment(childComplexity, args["request"].(model.ChaosExperimentRequest), args["projectID"].(string)), true

	case "Mutation.createEnvironment":
		if e.complexity.Mutation.CreateEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_createEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEnvironment(childComplexity, args["projectID"].(string), args["request"].(*model.CreateEnvironmentRequest)), true

	case "Mutation.createImageRegistry":
		if e.complexity.Mutation.CreateImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_createImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateImageRegistry(childComplexity, args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput)), true

	case "Mutation.deleteChaosExperiment":
		if e.complexity.Mutation.DeleteChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChaosExperiment(childComplexity, args["experimentID"].(string), args["experimentRunID"].(*string), args["projectID"].(string)), true

	case "Mutation.deleteChaosHub":
		if e.complexity.Mutation.DeleteChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChaosHub(childComplexity, args["projectID"].(string), args["hubID"].(string)), true

	case "Mutation.deleteEnvironment":
		if e.complexity.Mutation.DeleteEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEnvironment(childComplexity, args["projectID"].(string), args["environmentID"].(string)), true

	case "Mutation.deleteImageRegistry":
		if e.complexity.Mutation.DeleteImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_deleteImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string)), true

	case "Mutation.deleteInfra":
		if e.complexity.Mutation.DeleteInfra == nil {
			break
		}

		args, err := ec.field_Mutation_deleteInfra_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteInfra(childComplexity, args["projectID"].(string), args["infraID"].(string)), true

	case "Mutation.disableGitOps":
		if e.complexity.Mutation.DisableGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_disableGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableGitOps(childComplexity, args["projectID"].(string)), true

	case "Mutation.enableGitOps":
		if e.complexity.Mutation.EnableGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_enableGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableGitOps(childComplexity, args["configurations"].(model.GitConfig)), true

	case "Mutation.generateSSHKey":
		if e.complexity.Mutation.GenerateSSHKey == nil {
			break
		}

		return e.complexity.Mutation.GenerateSSHKey(childComplexity), true

	case "Mutation.getManifestWithInfraID":
		if e.complexity.Mutation.GetManifestWithInfraID == nil {
			break
		}

		args, err := ec.field_Mutation_getManifestWithInfraID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetManifestWithInfraID(childComplexity, args["projectID"].(string), args["infraID"].(string), args["accessKey"].(string)), true

	case "Mutation.gitopsNotifier":
		if e.complexity.Mutation.GitopsNotifier == nil {
			break
		}

		args, err := ec.field_Mutation_gitopsNotifier_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GitopsNotifier(childComplexity, args["clusterInfo"].(model.InfraIdentity), args["experimentID"].(string)), true

	case "Mutation.kubeObj":
		if e.complexity.Mutation.KubeObj == nil {
			break
		}

		args, err := ec.field_Mutation_kubeObj_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.KubeObj(childComplexity, args["request"].(model.KubeObjectData)), true

	case "Mutation.podLog":
		if e.complexity.Mutation.PodLog == nil {
			break
		}

		args, err := ec.field_Mutation_podLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PodLog(childComplexity, args["request"].(model.PodLog)), true

	case "Mutation.registerInfra":
		if e.complexity.Mutation.RegisterInfra == nil {
			break
		}

		args, err := ec.field_Mutation_registerInfra_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterInfra(childComplexity, args["projectID"].(string), args["request"].(model.RegisterInfraRequest)), true

	case "Mutation.runChaosExperiment":
		if e.complexity.Mutation.RunChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_runChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RunChaosExperiment(childComplexity, args["experimentID"].(string), args["projectID"].(string)), true

	case "Mutation.saveChaosExperiment":
		if e.complexity.Mutation.SaveChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_saveChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveChaosExperiment(childComplexity, args["request"].(model.SaveChaosExperimentRequest), args["projectID"].(string)), true

	case "Mutation.saveChaosHub":
		if e.complexity.Mutation.SaveChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_saveChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveChaosHub(childComplexity, args["projectID"].(string), args["request"].(model.CreateChaosHubRequest)), true

	case "Mutation.syncChaosHub":
		if e.complexity.Mutation.SyncChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_syncChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncChaosHub(childComplexity, args["id"].(string), args["projectID"].(string)), true

	case "Mutation.updateChaosExperiment":
		if e.complexity.Mutation.UpdateChaosExperiment == nil {
			break
		}

		args, err := ec.field_Mutation_updateChaosExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChaosExperiment(childComplexity, args["request"].(*model.ChaosExperimentRequest), args["projectID"].(string)), true

	case "Mutation.updateChaosHub":
		if e.complexity.Mutation.UpdateChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_updateChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChaosHub(childComplexity, args["projectID"].(string), args["request"].(model.UpdateChaosHubRequest)), true

	case "Mutation.updateEnvironment":
		if e.complexity.Mutation.UpdateEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_updateEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEnvironment(childComplexity, args["projectID"].(string), args["request"].(*model.UpdateEnvironmentRequest)), true

	case "Mutation.updateGitOps":
		if e.complexity.Mutation.UpdateGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_updateGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGitOps(childComplexity, args["configurations"].(model.GitConfig)), true

	case "Mutation.updateImageRegistry":
		if e.complexity.Mutation.UpdateImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_updateImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput)), true

	case "ObjectData.labels":
		if e.complexity.ObjectData.Labels == nil {
			break
		}

		return e.complexity.ObjectData.Labels(childComplexity), true

	case "ObjectData.name":
		if e.complexity.ObjectData.Name == nil {
			break
		}

		return e.complexity.ObjectData.Name(childComplexity), true

	case "PackageInformation.experiments":
		if e.complexity.PackageInformation.Experiments == nil {
			break
		}

		return e.complexity.PackageInformation.Experiments(childComplexity), true

	case "PackageInformation.packageName":
		if e.complexity.PackageInformation.PackageName == nil {
			break
		}

		return e.complexity.PackageInformation.PackageName(childComplexity), true

	case "PodLogResponse.experimentRunID":
		if e.complexity.PodLogResponse.ExperimentRunID == nil {
			break
		}

		return e.complexity.PodLogResponse.ExperimentRunID(childComplexity), true

	case "PodLogResponse.log":
		if e.complexity.PodLogResponse.Log == nil {
			break
		}

		return e.complexity.PodLogResponse.Log(childComplexity), true

	case "PodLogResponse.podName":
		if e.complexity.PodLogResponse.PodName == nil {
			break
		}

		return e.complexity.PodLogResponse.PodName(childComplexity), true

	case "PodLogResponse.podType":
		if e.complexity.PodLogResponse.PodType == nil {
			break
		}

		return e.complexity.PodLogResponse.PodType(childComplexity), true

	case "PredefinedExperimentList.experimentCSV":
		if e.complexity.PredefinedExperimentList.ExperimentCsv == nil {
			break
		}

		return e.complexity.PredefinedExperimentList.ExperimentCsv(childComplexity), true

	case "PredefinedExperimentList.experimentManifest":
		if e.complexity.PredefinedExperimentList.ExperimentManifest == nil {
			break
		}

		return e.complexity.PredefinedExperimentList.ExperimentManifest(childComplexity), true

	case "PredefinedExperimentList.experimentName":
		if e.complexity.PredefinedExperimentList.ExperimentName == nil {
			break
		}

		return e.complexity.PredefinedExperimentList.ExperimentName(childComplexity), true

	case "Provider.name":
		if e.complexity.Provider.Name == nil {
			break
		}

		return e.complexity.Provider.Name(childComplexity), true

	case "Query.getChaosFault":
		if e.complexity.Query.GetChaosFault == nil {
			break
		}

		args, err := ec.field_Query_getChaosFault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetChaosFault(childComplexity, args["projectID"].(string), args["request"].(model.ExperimentRequest)), true

	case "Query.getChaosHub":
		if e.complexity.Query.GetChaosHub == nil {
			break
		}

		args, err := ec.field_Query_getChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetChaosHub(childComplexity, args["projectID"].(string), args["chaosHubID"].(string)), true

	case "Query.getChaosHubStats":
		if e.complexity.Query.GetChaosHubStats == nil {
			break
		}

		args, err := ec.field_Query_getChaosHubStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetChaosHubStats(childComplexity, args["projectID"].(string)), true

	case "Query.getEnvironment":
		if e.complexity.Query.GetEnvironment == nil {
			break
		}

		args, err := ec.field_Query_getEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEnvironment(childComplexity, args["projectID"].(string), args["environmentID"].(string)), true

	case "Query.getExperiment":
		if e.complexity.Query.GetExperiment == nil {
			break
		}

		args, err := ec.field_Query_getExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperiment(childComplexity, args["projectID"].(string), args["experimentID"].(string)), true

	case "Query.getExperimentRun":
		if e.complexity.Query.GetExperimentRun == nil {
			break
		}

		args, err := ec.field_Query_getExperimentRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperimentRun(childComplexity, args["projectID"].(string), args["experimentRunID"].(string)), true

	case "Query.getExperimentRunStats":
		if e.complexity.Query.GetExperimentRunStats == nil {
			break
		}

		args, err := ec.field_Query_getExperimentRunStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperimentRunStats(childComplexity, args["projectID"].(string)), true

	case "Query.getExperimentStats":
		if e.complexity.Query.GetExperimentStats == nil {
			break
		}

		args, err := ec.field_Query_getExperimentStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperimentStats(childComplexity, args["projectID"].(string)), true

	case "Query.getGitOpsDetails":
		if e.complexity.Query.GetGitOpsDetails == nil {
			break
		}

		args, err := ec.field_Query_getGitOpsDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGitOpsDetails(childComplexity, args["projectID"].(string)), true

	case "Query.getImageRegistry":
		if e.complexity.Query.GetImageRegistry == nil {
			break
		}

		args, err := ec.field_Query_getImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string)), true

	case "Query.getInfra":
		if e.complexity.Query.GetInfra == nil {
			break
		}

		args, err := ec.field_Query_getInfra_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInfra(childComplexity, args["projectID"].(string), args["infraID"].(string)), true

	case "Query.getInfraDetails":
		if e.complexity.Query.GetInfraDetails == nil {
			break
		}

		args, err := ec.field_Query_getInfraDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInfraDetails(childComplexity, args["infraID"].(string), args["projectID"].(string)), true

	case "Query.getInfraManifest":
		if e.complexity.Query.GetInfraManifest == nil {
			break
		}

		args, err := ec.field_Query_getInfraManifest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInfraManifest(childComplexity, args["infraID"].(string), args["upgrade"].(bool), args["projectID"].(string)), true

	case "Query.getInfraStats":
		if e.complexity.Query.GetInfraStats == nil {
			break
		}

		args, err := ec.field_Query_getInfraStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInfraStats(childComplexity, args["projectID"].(string)), true

	case "Query.getPredefinedExperiment":
		if e.complexity.Query.GetPredefinedExperiment == nil {
			break
		}

		args, err := ec.field_Query_getPredefinedExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPredefinedExperiment(childComplexity, args["hubID"].(string), args["experimentName"].([]string), args["projectID"].(string)), true

	case "Query.getServerVersion":
		if e.complexity.Query.GetServerVersion == nil {
			break
		}

		return e.complexity.Query.GetServerVersion(childComplexity), true

	case "Query.getVersionDetails":
		if e.complexity.Query.GetVersionDetails == nil {
			break
		}

		args, err := ec.field_Query_getVersionDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetVersionDetails(childComplexity, args["projectID"].(string)), true

	case "Query.listChaosFaults":
		if e.complexity.Query.ListChaosFaults == nil {
			break
		}

		args, err := ec.field_Query_listChaosFaults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListChaosFaults(childComplexity, args["hubID"].(string), args["projectID"].(string)), true

	case "Query.listChaosHub":
		if e.complexity.Query.ListChaosHub == nil {
			break
		}

		args, err := ec.field_Query_listChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListChaosHub(childComplexity, args["projectID"].(string), args["request"].(*model.ListChaosHubRequest)), true

	case "Query.listEnvironments":
		if e.complexity.Query.ListEnvironments == nil {
			break
		}

		args, err := ec.field_Query_listEnvironments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListEnvironments(childComplexity, args["projectID"].(string), args["request"].(*model.ListEnvironmentRequest)), true

	case "Query.listExperiment":
		if e.complexity.Query.ListExperiment == nil {
			break
		}

		args, err := ec.field_Query_listExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListExperiment(childComplexity, args["projectID"].(string), args["request"].(model.ListExperimentRequest)), true

	case "Query.listExperimentRun":
		if e.complexity.Query.ListExperimentRun == nil {
			break
		}

		args, err := ec.field_Query_listExperimentRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListExperimentRun(childComplexity, args["projectID"].(string), args["request"].(model.ListExperimentRunRequest)), true

	case "Query.listImageRegistry":
		if e.complexity.Query.ListImageRegistry == nil {
			break
		}

		args, err := ec.field_Query_listImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListImageRegistry(childComplexity, args["projectID"].(string)), true

	case "Query.listInfras":
		if e.complexity.Query.ListInfras == nil {
			break
		}

		args, err := ec.field_Query_listInfras_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListInfras(childComplexity, args["projectID"].(string), args["request"].(*model.ListInfraRequest)), true

	case "Query.listPredefinedExperiments":
		if e.complexity.Query.ListPredefinedExperiments == nil {
			break
		}

		args, err := ec.field_Query_listPredefinedExperiments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPredefinedExperiments(childComplexity, args["hubID"].(string), args["projectID"].(string)), true

	case "RecentExperimentRun.createdAt":
		if e.complexity.RecentExperimentRun.CreatedAt == nil {
			break
		}

		return e.complexity.RecentExperimentRun.CreatedAt(childComplexity), true

	case "RecentExperimentRun.createdBy":
		if e.complexity.RecentExperimentRun.CreatedBy == nil {
			break
		}

		return e.complexity.RecentExperimentRun.CreatedBy(childComplexity), true

	case "RecentExperimentRun.experimentRunID":
		if e.complexity.RecentExperimentRun.ExperimentRunID == nil {
			break
		}

		return e.complexity.RecentExperimentRun.ExperimentRunID(childComplexity), true

	case "RecentExperimentRun.phase":
		if e.complexity.RecentExperimentRun.Phase == nil {
			break
		}

		return e.complexity.RecentExperimentRun.Phase(childComplexity), true

	case "RecentExperimentRun.resiliencyScore":
		if e.complexity.RecentExperimentRun.ResiliencyScore == nil {
			break
		}

		return e.complexity.RecentExperimentRun.ResiliencyScore(childComplexity), true

	case "RecentExperimentRun.updatedAt":
		if e.complexity.RecentExperimentRun.UpdatedAt == nil {
			break
		}

		return e.complexity.RecentExperimentRun.UpdatedAt(childComplexity), true

	case "RecentExperimentRun.updatedBy":
		if e.complexity.RecentExperimentRun.UpdatedBy == nil {
			break
		}

		return e.complexity.RecentExperimentRun.UpdatedBy(childComplexity), true

	case "RegisterInfraResponse.infraID":
		if e.complexity.RegisterInfraResponse.InfraID == nil {
			break
		}

		return e.complexity.RegisterInfraResponse.InfraID(childComplexity), true

	case "RegisterInfraResponse.manifest":
		if e.complexity.RegisterInfraResponse.Manifest == nil {
			break
		}

		return e.complexity.RegisterInfraResponse.Manifest(childComplexity), true

	case "RegisterInfraResponse.name":
		if e.complexity.RegisterInfraResponse.Name == nil {
			break
		}

		return e.complexity.RegisterInfraResponse.Name(childComplexity), true

	case "RegisterInfraResponse.token":
		if e.complexity.RegisterInfraResponse.Token == nil {
			break
		}

		return e.complexity.RegisterInfraResponse.Token(childComplexity), true

	case "ResilienceScoreCategory.count":
		if e.complexity.ResilienceScoreCategory.Count == nil {
			break
		}

		return e.complexity.ResilienceScoreCategory.Count(childComplexity), true

	case "ResilienceScoreCategory.id":
		if e.complexity.ResilienceScoreCategory.ID == nil {
			break
		}

		return e.complexity.ResilienceScoreCategory.ID(childComplexity), true

	case "RunChaosExperimentResponse.notifyID":
		if e.complexity.RunChaosExperimentResponse.NotifyID == nil {
			break
		}

		return e.complexity.RunChaosExperimentResponse.NotifyID(childComplexity), true

	case "SSHKey.privateKey":
		if e.complexity.SSHKey.PrivateKey == nil {
			break
		}

		return e.complexity.SSHKey.PrivateKey(childComplexity), true

	case "SSHKey.publicKey":
		if e.complexity.SSHKey.PublicKey == nil {
			break
		}

		return e.complexity.SSHKey.PublicKey(childComplexity), true

	case "ServerVersionResponse.key":
		if e.complexity.ServerVersionResponse.Key == nil {
			break
		}

		return e.complexity.ServerVersionResponse.Key(childComplexity), true

	case "ServerVersionResponse.value":
		if e.complexity.ServerVersionResponse.Value == nil {
			break
		}

		return e.complexity.ServerVersionResponse.Value(childComplexity), true

	case "Spec.categoryDescription":
		if e.complexity.Spec.CategoryDescription == nil {
			break
		}

		return e.complexity.Spec.CategoryDescription(childComplexity), true

	case "Spec.chaosExpCRDLink":
		if e.complexity.Spec.ChaosExpCRDLink == nil {
			break
		}

		return e.complexity.Spec.ChaosExpCRDLink(childComplexity), true

	case "Spec.chaosType":
		if e.complexity.Spec.ChaosType == nil {
			break
		}

		return e.complexity.Spec.ChaosType(childComplexity), true

	case "Spec.displayName":
		if e.complexity.Spec.DisplayName == nil {
			break
		}

		return e.complexity.Spec.DisplayName(childComplexity), true

	case "Spec.experiments":
		if e.complexity.Spec.Experiments == nil {
			break
		}

		return e.complexity.Spec.Experiments(childComplexity), true

	case "Spec.faults":
		if e.complexity.Spec.Faults == nil {
			break
		}

		return e.complexity.Spec.Faults(childComplexity), true

	case "Spec.keywords":
		if e.complexity.Spec.Keywords == nil {
			break
		}

		return e.complexity.Spec.Keywords(childComplexity), true

	case "Spec.links":
		if e.complexity.Spec.Links == nil {
			break
		}

		return e.complexity.Spec.Links(childComplexity), true

	case "Spec.maintainers":
		if e.complexity.Spec.Maintainers == nil {
			break
		}

		return e.complexity.Spec.Maintainers(childComplexity), true

	case "Spec.maturity":
		if e.complexity.Spec.Maturity == nil {
			break
		}

		return e.complexity.Spec.Maturity(childComplexity), true

	case "Spec.minKubeVersion":
		if e.complexity.Spec.MinKubeVersion == nil {
			break
		}

		return e.complexity.Spec.MinKubeVersion(childComplexity), true

	case "Spec.platforms":
		if e.complexity.Spec.Platforms == nil {
			break
		}

		return e.complexity.Spec.Platforms(childComplexity), true

	case "Spec.provider":
		if e.complexity.Spec.Provider == nil {
			break
		}

		return e.complexity.Spec.Provider(childComplexity), true

	case "StopExperimentRunsRequest.experimentID":
		if e.complexity.StopExperimentRunsRequest.ExperimentID == nil {
			break
		}

		return e.complexity.StopExperimentRunsRequest.ExperimentID(childComplexity), true

	case "StopExperimentRunsRequest.experimentRunID":
		if e.complexity.StopExperimentRunsRequest.ExperimentRunID == nil {
			break
		}

		return e.complexity.StopExperimentRunsRequest.ExperimentRunID(childComplexity), true

	case "StopExperimentRunsRequest.projectID":
		if e.complexity.StopExperimentRunsRequest.ProjectID == nil {
			break
		}

		return e.complexity.StopExperimentRunsRequest.ProjectID(childComplexity), true

	case "Subscription.getInfraEvents":
		if e.complexity.Subscription.GetInfraEvents == nil {
			break
		}

		args, err := ec.field_Subscription_getInfraEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetInfraEvents(childComplexity, args["projectID"].(string)), true

	case "Subscription.getKubeObject":
		if e.complexity.Subscription.GetKubeObject == nil {
			break
		}

		args, err := ec.field_Subscription_getKubeObject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetKubeObject(childComplexity, args["request"].(model.KubeObjectRequest)), true

	case "Subscription.getPodLog":
		if e.complexity.Subscription.GetPodLog == nil {
			break
		}

		args, err := ec.field_Subscription_getPodLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetPodLog(childComplexity, args["request"].(model.PodLogRequest)), true

	case "Subscription.infraConnect":
		if e.complexity.Subscription.InfraConnect == nil {
			break
		}

		args, err := ec.field_Subscription_infraConnect_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.InfraConnect(childComplexity, args["request"].(model.InfraIdentity)), true

	case "UserDetails.email":
		if e.complexity.UserDetails.Email == nil {
			break
		}

		return e.complexity.UserDetails.Email(childComplexity), true

	case "UserDetails.userID":
		if e.complexity.UserDetails.UserID == nil {
			break
		}

		return e.complexity.UserDetails.UserID(childComplexity), true

	case "UserDetails.username":
		if e.complexity.UserDetails.Username == nil {
			break
		}

		return e.complexity.UserDetails.Username(childComplexity), true

	case "Weightages.faultName":
		if e.complexity.Weightages.FaultName == nil {
			break
		}

		return e.complexity.Weightages.FaultName(childComplexity), true

	case "Weightages.weightage":
		if e.complexity.Weightages.Weightage == nil {
			break
		}

		return e.complexity.Weightages.Weightage(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	&ast.Source{Name: "../definitions/shared/chaos_experiment.graphqls", Input: `"""
Defines the details of the weightages of each chaos fault in the experiment
"""
input WeightagesInput {
  """
  Name of the fault
  """
  faultName: String!
  """
  Weightage of the fault
  """
  weightage: Int!
}

enum ExperimentType {
  All
  Experiment
  CronExperiment
  ChaosEngine
  ChaosSchedule
}

enum ExperimentRunStatus {
  All
  Running
  Completed
  Completed_With_Error
  Stopped
  Skipped
  Error
  Timeout
  NA
}

enum ScheduleType {
  CRON
  NON_CRON
  ALL
}

"""
Defines the details for a chaos experiment
"""
input SaveChaosExperimentRequest {
  """
  ID of the experiment
  """
  id: String!
  """
  Type of the experiment
  """
  type: ExperimentType
  """
  Name of the experiment
  """
  name: String!
  """
  Description of the experiment
  """
  description: String!
  """
  Manifest of the experiment
  """
  manifest: String!
  """
  ID of the target infrastructure in which the experiment will run
  """
  infraID: ID!
  """
  Tags of the infrastructure
  """
  tags: [String!]
}

"""
Defines the details for a chaos experiment
"""
input ChaosExperimentRequest {
  """
  ID of the experiment
  """
  experimentID: String
  """
  Boolean check indicating if the created scenario will be executed or not
  """
  runExperiment: Boolean
  """
  Manifest of the experiment
  """
  experimentManifest: String!
  """
  Type of the experiment
  """
  experimentType: ExperimentType
  """
  Cron syntax of the experiment schedule
  """
  cronSyntax: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Description of the experiment
  """
  experimentDescription: String!
  """
  Array containing weightage and name of each chaos experiment in the experiment
  """
  weightages: [WeightagesInput!]!
  """
  Bool value indicating whether the experiment is a custom experiment or not
  """
  isCustomExperiment: Boolean!
  """
  ID of the target infra in which the experiment will run
  """
  infraID: ID!
  """
  Tags of the infra
  """
  tags: [String!]
}

"""
Defines the response received for querying the details of chaos experiment
"""
type ChaosExperimentResponse {
  """
  ID of the experiment
  """
  experimentID: String!
  projectID: ID!
  """
  Cron syntax of the experiment schedule
  """
  cronSyntax: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Description of the experiment
  """
  experimentDescription: String!
  """
  Bool value indicating whether the experiment is a custom experiment or not
  """
  isCustomExperiment: Boolean!
  """
  Tags of the infra
  """
  tags: [String!]
}

"""
Defines the details for a experiment run
"""
input ExperimentRunRequest {
  """
  ID of the experiment
  """
  experimentID: String!
  """
  notifyID is required to give an ack for non cron experiment execution
  """
  notifyID: String
  """
  ID of the experiment run which is to be queried
  """
  experimentRunID: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Stores all the experiment run details related to the nodes of DAG graph and chaos results of the experiments
  """
  executionData: String!
  """
  ID of the infra infra in which the experiment is running
  """
  infraID: InfraIdentity!
  """
  ID of the revision which consists manifest details
  """
  revisionID: String!
  """
  Bool value indicating if the experiment run has completed
  """
  completed: Boolean!
  """
  Bool value indicating if the experiment run has removed
  """
  isRemoved: Boolean
  """
  User who has updated the experiment
  """
  updatedBy: String!
}

"""
Defines the start date and end date for the filtering the data
"""
input DateRange {
  """
  Start date
  """
  startDate: String!
  """
  End date
  """
  endDate: String
}

"""
Defines input type for experiment run filter
"""
input ExperimentRunFilterInput {
  """
  Name of the experiment
  """
  experimentName: String
  """
  Name of the infra infra
  """
  infraID: String
  """
  Type of the experiment
  """
  experimentType: ScheduleType
  """
  Status of the experiment run
  """
  experimentStatus: ExperimentRunStatus
  """
  Date range for filtering purpose
  """
  dateRange: DateRange
  """
  ID of experiment run
  """
  experimentRunID: String
  """
  Array of experiment run status
  """
  experimentRunStatus: [String]
  """
  Type of infras
  """
  infraTypes: [InfrastructureType]
}

"""
Defines data required to fetch paginated data
"""
input Pagination {
  """
  Page number for which data will be fetched
  """
  page: Int!
  """
  Number of data to be fetched
  """
  limit: Int!
}

enum ExperimentSortingField {
  NAME
  TIME
}

"""
Defines sorting options for experiment runs
"""
input ExperimentRunSortInput {
  """
  Field in which sorting will be done
  """
  field: ExperimentSortingField!
  """
  Bool value indicating whether the sorting will be done in ascending order
  """
  ascending: Boolean
}

"""
Defines the details for experiment runs
"""
input ListExperimentRunRequest {
  """
  Array of experiment run IDs for which details will be fetched
  """
  experimentRunIDs: [ID]
  """
  Array of experiment IDs for which details will be fetched
  """
  experimentIDs: [ID]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching sorted data
  """
  sort: ExperimentRunSortInput
  """
  Details for fetching filtered data
  """
  filter: ExperimentRunFilterInput
}

"""
Defines the details of the weightages of each chaos fault in the experiment
"""
type Weightages {
  """
  Name of the fault
  """
  faultName: String!
  """
  Weightage of the experiment
  """
  weightage: Int!
}

"""
Defines the details of a experiment run
"""
type ExperimentRun implements Audit {
  projectID: ID!
  """
  ID of the experiment run which is to be queried
  """
  experimentRunID: ID!
  """
  Type of the experiment
  """
  experimentType: String
  """
  ID of the experiment
  """
  experimentID: ID!
  """
  Array containing weightage and name of each chaos fault in the experiment
  """
  weightages: [Weightages!]!
  """
  Timestamp at which experiment run was last updated
  """
  updatedAt: String!
  """
  Timestamp at which experiment run was created
  """
  createdAt: String!
  """
  Target infra in which the experiment will run
  """
  infra: Infra!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Manifest of the experiment run
  """
  experimentManifest: String!
  """
  Phase of the experiment run
  """
  phase: ExperimentRunStatus!
  """
  Resiliency score of the experiment
  """
  resiliencyScore: Float
  """
  Number of faults passed
  """
  faultsPassed: Int
  """
  Number of faults failed
  """
  faultsFailed: Int
  """
  Number of faults awaited
  """
  faultsAwaited: Int
  """
  Number of faults stopped
  """
  faultsStopped: Int
  """
  Number of faults which are not available
  """
  faultsNa: Int
  """
  Total number of faults
  """
  totalFaults: Int
  """
  Stores all the experiment run details related to the nodes of DAG graph and chaos results of the faults
  """
  executionData: String!
  """
  Bool value indicating if the experiment run has removed
  """
  isRemoved: Boolean
  """
  User who has updated the experiment
  """
  updatedBy: UserDetails
  """
  User who has created the experiment run
  """
  createdBy: UserDetails
}

"""
Defines the details of a experiment to sent as response
"""
type ListExperimentRunResponse {
  """
  Total number of experiment runs
  """
  totalNoOfExperimentRuns: Int!
  """
  Defines details of experiment runs
  """
  experimentRuns: [ExperimentRun]!
}

"""
Defines filter options for experiments
"""
input ExperimentFilterInput {
  """
  Name of the experiment
  """
  experimentName: String
  """
  Name of the infra in which the experiment is running
  """
  infraName: String
  """
  ID of the infra in which the experiment is running
  """
  infraID: String
  """
  Bool value indicating if Chaos Infrastructure is active
  """
  infraActive: Boolean
  """
  Scenario type of the experiment i.e. CRON or NON_CRON
  """
  scheduleType: ScheduleType
  """
  Status of the latest experiment run
  """
  status: String
  """
  Date range for filtering purpose
  """
  dateRange: DateRange
  """
  Type of infras
  """
  infraTypes: [InfrastructureType]
}

"""
Defines the details for a experiment
"""
input ListExperimentRequest {
  """
  Array of experiment IDs for which details will be fetched
  """
  experimentIDs: [ID]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching sorted data
  """
  sort: ExperimentSortInput
  """
  Details for fetching filtered data
  """
  filter: ExperimentFilterInput
}

"""
Defines sorting options for experiment
"""
input ExperimentSortInput {
  """
  Field in which sorting will be done
  """
  field: ExperimentSortingField!
  """
  Bool value indicating whether the sorting will be done in ascending order
  """
  ascending: Boolean
}

type RecentExperimentRun implements Audit {
  """
  ID of the experiment run which is to be queried
  """
  experimentRunID: ID!
  """
  Phase of the experiment run
  """
  phase: String!
  """
  Resiliency score of the experiment
  """
  resiliencyScore: Float
  """
  Timestamp when the experiment was last updated
  """
  updatedAt: String!
  """
  Timestamp when the experiment was created
  """
  createdAt: String!
  """
  User who created the experiment run
  """
  createdBy: UserDetails
  """
  User who updated the experiment run
  """
  updatedBy: UserDetails
}

"""
Defines the details for a experiment
"""
type Experiment implements ResourceDetails & Audit {
  projectID: ID!
  """
  ID of the experiment
  """
  experimentID: String!
  """
  Type of the experiment
  """
  experimentType: String
  """
  Manifest of the experiment
  """
  experimentManifest: String!
  """
  Cron syntax of the experiment schedule
  """
  cronSyntax: String!
  """
  Name of the experiment
  """
  name: String!
  """
  Description of the experiment
  """
  description: String!
  """
  Array containing weightage and name of each chaos fault in the experiment
  """
  weightages: [Weightages!]!
  """
  Bool value indicating whether the experiment is a custom experiment or not
  """
  isCustomExperiment: Boolean!
  """
  Timestamp when the experiment was last updated
  """
  updatedAt: String!
  """
  Timestamp when the experiment was created
  """
  createdAt: String!
  """
  Target infra in which the experiment will run
  """
  infra: Infra
  """
  Bool value indicating if the experiment has removed
  """
  isRemoved: Boolean!
  """
  Tags of the experiment
  """
  tags: [String!]
  """
  User who created the experiment
  """
  createdBy: UserDetails
  """
  Array of object containing details of recent experiment runs
  """
  recentExperimentRunDetails: [RecentExperimentRun]
  """
  Details of the user who updated the experiment
  """
  updatedBy: UserDetails
}

"""
Defines the details for a given experiment with some additional data
"""
type GetExperimentResponse {
  """
  Details of experiment
  """
  experimentDetails: Experiment!
  """
  Average resiliency score of the experiment
  """
  averageResiliencyScore: Float
}

"""
Defines the details for a experiment with total experiment count
"""
type ListExperimentResponse {
  """
  Total number of experiments
  """
  totalNoOfExperiments: Int!
  """
  Details related to the experiments
  """
  experiments: [Experiment]!
}

"""
Defines the request for stopping a experiment
"""
type StopExperimentRunsRequest {
  projectID: ID!
  """
  ID of the experiment to be stopped
  """
  experimentID: String!
  """
  ID of the experiment run to be stopped
  """
  experimentRunID: String
}

type RunChaosExperimentResponse {
  notifyID: ID!
}

type GetExperimentRunStatsResponse {
  """
  Total number of experiment runs
  """
  totalExperimentRuns: Int!
  """
  Total number of completed experiments runs
  """
  totalCompletedExperimentRuns: Int!
  """
  Total number of stopped experiment runs
  """
  totalTerminatedExperimentRuns: Int!
  """
  Total number of running experiment runs
  """
  totalRunningExperimentRuns: Int!
  """
  Total number of stopped experiment runs
  """
  totalStoppedExperimentRuns: Int!
  """
  Total number of errored experiment runs
  """
  totalErroredExperimentRuns: Int!
}

type ResilienceScoreCategory {
  """
  Lower bound of the range(inclusive)
  """
  id: Int!
  """
  total experiments with avg resilience score between lower bound and upper bound(exclusive)
  """
  count: Int!
}

type GetExperimentStatsResponse {
  """
  Total number of experiments
  """
  totalExperiments: Int!
  """
  Total number of cron experiments
  """
  totalExpCategorizedByResiliencyScore: [ResilienceScoreCategory]!
}

extend type Query {
  """
  Returns experiment run based on experiment run ID
  """
  getExperimentRun(projectID: ID!, experimentRunID: String!): ExperimentRun!

  """
  Returns the list of experiment run based on various filter parameters
  """
  listExperimentRun(
    projectID: ID!
    request: ListExperimentRunRequest!
  ): ListExperimentRunResponse!

  """
  Returns the experiment based on experiment ID
  """
  getExperiment(projectID: ID!, experimentID: String!): GetExperimentResponse!

  """
  Returns the list of experiments based on various filter parameters
  """
  listExperiment(
    projectID: ID!
    request: ListExperimentRequest!
  ): ListExperimentResponse!

  """
  Query to get experiment run stats
  """
  getExperimentRunStats(projectID: ID!): GetExperimentRunStatsResponse!
  """
  Query to get experiment stats
  """
  getExperimentStats(projectID: ID!): GetExperimentStatsResponse!
}

extend type Mutation {
  """
  Creates a new experiment and applies its manifest
  """
  createChaosExperiment(
    request: ChaosExperimentRequest!
    projectID: ID!
  ): ChaosExperimentResponse!

  """
  Saves a new experiment or updates if already exists
  """
  saveChaosExperiment(
    request: SaveChaosExperimentRequest!
    projectID: ID!
  ): String!

  """
  Run the chaos experiment (used by frontend)
  """
  runChaosExperiment(
    experimentID: String!
    projectID: ID!
  ): RunChaosExperimentResponse!

  """
  Updates the experiment
  """
  updateChaosExperiment(
    request: ChaosExperimentRequest
    projectID: ID!
  ): ChaosExperimentResponse!

  """
  Removes a experiment from infra
  """
  deleteChaosExperiment(
    experimentID: String!
    experimentRunID: String
    projectID: ID!
  ): Boolean!

  """
  Creates a new experiment run and sends it to subscriber
  """
  # authorized directive not required
  chaosExperimentRun(request: ExperimentRunRequest!): String!
}
`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/chaos_infrastructure.graphqls", Input: `directive @authorized on FIELD_DEFINITION

"""
UpdateStatus represents if infra needs to be updated
"""
enum UpdateStatus {
  AVAILABLE
  MANDATORY
  NOT_REQUIRED
}

"""
Defines the details for a infra
"""
type Infra implements ResourceDetails & Audit {
  projectID: ID!
  """
  ID of the infra
  """
  infraID: ID!
  """
  Name of the infra
  """
  name: String!
  """
  Description of the infra
  """
  description: String
  """
  Tags of the infra
  """
  tags: [String!]
  """
  Environment ID for the infra
  """
  environmentID: String!
  """
  Infra Platform Name eg. GKE,AWS, Others
  """
  platformName: String!
  """
  Boolean value indicating if chaos infrastructure is active or not
  """
  isActive: Boolean!
  """
  Boolean value indicating if chaos infrastructure is confirmed or not
  """
  isInfraConfirmed: Boolean!
  """
  Boolean value indicating if chaos infrastructure is removed or not
  """
  isRemoved: Boolean!
  """
  Timestamp when the infra was last updated
  """
  updatedAt: String!
  """
  Timestamp when the infra was created
  """
  createdAt: String!
  """
  Number of schedules created in the infra
  """
  noOfExperiments: Int
  """
  Number of experiments run in the infra
  """
  noOfExperimentRuns: Int
  """
  Token used to verify and retrieve the infra manifest
  """
  token: String!
  """
  Namespace where the infra is being installed
  """
  infraNamespace: String
  """
  Name of service account used by infra
  """
  serviceAccount: String
  """
  Scope of the infra : ns or cluster
  """
  infraScope: String!
  """
  Bool value indicating whether infra ns used already exists on infra or not
  """
  infraNsExists: Boolean
  """
  Bool value indicating whether service account used already exists on infra or not
  """
  infraSaExists: Boolean
  """
  Timestamp of the last experiment run in the infra
  """
  lastExperimentTimestamp: String
  """
  Timestamp when the infra got connected
  """
  startTime: String!
  """
  Version of the infra
  """
  version: String!
  """
  User who created the infra
  """
  createdBy: UserDetails
  """
  User who has updated the infra
  """
  updatedBy: UserDetails
  """
  Type of the infrastructure
  """
  infraType: InfrastructureType
  """
  update status of infra
  """
  updateStatus: UpdateStatus!
}

enum InfrastructureType {
  INTERNAL
  EXTERNAL
}

"""
Defines the details for the new infra being connected
"""
input RegisterInfraRequest {
  """
  Name of the infra
  """
  name: String!
  """
  Environment ID for the infra
  """
  environmentID: String!
  """
  Type of Infra : internal/external
  """
  infrastructureType: InfrastructureType!
  """
  Description of the infra
  """
  description: String
  """
  Infra Platform Name eg. GKE,AWS, Others
  """
  platformName: String!
  """
  Namespace where the infra is being installed
  """
  infraNamespace: String
  """
  Name of service account used by infra
  """
  serviceAccount: String
  """
  Scope of the infra : ns or infra
  """
  infraScope: String!
  """
  Bool value indicating whether infra ns used already exists on infra or not
  """
  infraNsExists: Boolean
  """
  Bool value indicating whether service account used already exists on infra or not
  """
  infraSaExists: Boolean
  """
  Bool value indicating whether infra will skip ssl checks or not
  """
  skipSsl: Boolean
  """
  Node selectors used by infra
  """
  nodeSelector: String
  """
  Node tolerations used by infra
  """
  tolerations: [Toleration]
  """
  Tags of the infra
  """
  tags: [String!]
}

input Toleration {
  tolerationSeconds: Int
  key: String
  operator: String
  effect: String
  value: String
}

type InfraEventResponse {
  eventID: ID!
  eventType: String!
  eventName: String!
  description: String!
  infra: Infra!
}

type ActionPayload {
  requestID: String!
  requestType: String!
  k8sManifest: String!
  namespace: String!
  externalData: String
  username: String
}

type InfraActionResponse {
  projectID: String!
  action: ActionPayload!
}

input NewInfraEventRequest {
  eventName: String!
  description: String!
  infraID: String!
  accessKey: String!
}

type ConfirmInfraRegistrationResponse {
  isInfraConfirmed: Boolean!
  newAccessKey: String
  infraID: String
}

"""
Response received for registering a new infra
"""
type RegisterInfraResponse {
  """
  Token used to verify and retrieve the infra manifest
  """
  token: String!
  """
  Unique ID for the newly registered infra
  """
  infraID: String!
  """
  Infra name as sent in request
  """
  name: String!
  """
  Infra Manifest
  """
  manifest: String!
}

"""
Defines the response received for querying querying the pod logs
"""
type PodLogResponse {
  """
  ID of the experiment run which is to be queried
  """
  experimentRunID: ID!
  """
  Name of the pod for which logs are queried
  """
  podName: String!
  """
  Type of the pod: chaosengine
  """
  podType: String!
  """
  Logs for the pod
  """
  log: String!
}

input InfraIdentity {
  infraID: String!
  accessKey: String!
  version: String!
}

"""
Defines the details for fetching the pod logs
"""
input PodLogRequest {
  """
  ID of the cluster
  """
  infraID: ID!
  """
  ID of a experiment run
  """
  experimentRunID: ID!
  """
  Name of the pod for which logs are required
  """
  podName: String!
  """
  Namespace where the pod is running
  """
  podNamespace: String!
  """
  Type of the pod: chaosEngine or not pod
  """
  podType: String!
  """
  Name of the experiment pod fetched from execution data
  """
  expPod: String
  """
  Name of the runner pod fetched from execution data
  """
  runnerPod: String
  """
  Namespace where the experiment is executing
  """
  chaosNamespace: String
}

"""
Response received for querying pod logs
"""
input PodLog {
  """
  ID of the cluster
  """
  infraID: InfraIdentity!
  """
  Unique request ID of a particular node which is being queried
  """
  requestID: ID!
  """
  ID of a experiment run
  """
  experimentRunID: ID!
  """
  Name of the pod for which logs are required
  """
  podName: String!
  """
  Type of the pod: chaosengine
  """
  podType: String!
  """
  Logs for the pod
  """
  log: String!
}

"""
Response received for querying Kubernetes Object
"""
type KubeObjectResponse {
  """
  ID of the infra in which the Kubernetes object is present
  """
  infraID: ID!
  """
  Type of the Kubernetes object
  """
  kubeObj: [KubeObject]!
}

"""
KubeObject consists of the namespace and the available resources in the same
"""
type KubeObject {
  """
  Namespace of the resource
  """
  namespace: String!
  """
  Details of the resource
  """
  data: [ObjectData]!
}

type ObjectData {
  """
  Labels present in the resource
  """
  labels: [String!]
  """
  Name of the resource
  """
  name: String!
}

input Workload {
  name: String!
  kind: String!
  namespace: String!
}

"""
Defines details for fetching Kubernetes object data
"""
input KubeObjectRequest {
  """
  ID of the infra in which the Kubernetes object is present
  """
  infraID: ID!
  """
  GVR Request
  """
  kubeObjRequest: KubeGVRRequest
  objectType: String!
  workloads: [Workload]
}

input KubeGVRRequest {
  group: String!
  version: String!
  resource: String!
}

"""
Defines the details of Kubernetes object
"""
input KubeObjectData {
  """
  Unique request ID for fetching Kubernetes object details
  """
  requestID: ID!
  """
  ID of the infra in which the Kubernetes object is present
  """
  infraID: InfraIdentity!
  """
  Type of the Kubernetes object
  """
  kubeObj: String!
}

"""
Defines filter options for infras
"""
input InfraFilterInput {
  """
  Name of the infra
  """
  name: String
  """
  ID of the infra
  """
  infraID: String
  """
  ID of the infra
  """
  description: String
  """
  Platform name of infra
  """
  platformName: String
  """
  Scope of infra
  """
  infraScope: INFRA_SCOPE
  """
  Status of infra
  """
  isActive: Boolean
  """
  Tags of an infra
  """
  tags: [String]
}

enum INFRA_SCOPE {
  namespace
  cluster
}

"""
Defines the details for a infra
"""
input ListInfraRequest {
  """
  Array of infra IDs for which details will be fetched
  """
  infraIDs: [ID!]
  """
  Environment ID
  """
  environmentIDs: [ID!]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching filtered data
  """
  filter: InfraFilterInput
}

"""
Defines the details for a infras with total infras count
"""
type ListInfraResponse {
  """
  Total number of infras
  """
  totalNoOfInfras: Int!
  """
  Details related to the infras
  """
  infras: [Infra]!
}

type GetInfraStatsResponse {
  """
  Total number of infrastructures
  """
  totalInfrastructures: Int!
  """
  Total number of active infrastructures
  """
  totalActiveInfrastructure: Int!
  """
  Total number of inactive infrastructures
  """
  totalInactiveInfrastructures: Int!
  """
  Total number of confirmed infrastructures
  """
  totalConfirmedInfrastructure: Int!
  """
  Total number of non confirmed infrastructures
  """
  totalNonConfirmedInfrastructures: Int!
}

"""
InfraVersionDetails returns the details of compatible infra versions and the latest infra version supported
"""
type InfraVersionDetails {
  """
  Latest infra version supported
  """
  latestVersion: String!
  """
  List of all infra versions supported
  """
  compatibleVersions: [String!]!
}

"""
Response received for fetching GQL server version
"""
type ServerVersionResponse {
  """
  Returns server version key
  """
  key: String!
  """
  Returns server version value
  """
  value: String!
}

extend type Query {
  # INFRA OPERATIONS
  """
  Returns infra with a particular infraID in the project
  """
  getInfra(projectID: ID!, infraID: String!): Infra! @authorized

  """
  Returns infras with a particular infra type in the project
  """
  listInfras(projectID: ID!, request: ListInfraRequest): ListInfraResponse!
    @authorized

  """
  Returns infra details based on identifiers
  """
  getInfraDetails(infraID: ID!, projectID: ID!): Infra! @authorized

  """
  Returns the manifest for a given infraID
  """
  getInfraManifest(infraID: ID!, upgrade: Boolean!, projectID: ID!): String!
    @authorized

  """
  Query to get experiment stats
  """
  getInfraStats(projectID: ID!): GetInfraStatsResponse! @authorized

  """
  Query to get the latest version of infra available
  """
  getVersionDetails(projectID: ID!): InfraVersionDetails! @authorized
  """
  Returns version of gql server
  """
  getServerVersion: ServerVersionResponse!
}

extend type Mutation {
  """
  Connect a new infra for a user in a specified project
  """
  registerInfra(
    projectID: ID!
    request: RegisterInfraRequest!
  ): RegisterInfraResponse!

  """
  Confirms the subscriber's registration with the control plane
  """
  # authorized directive not required
  confirmInfraRegistration(
    request: InfraIdentity!
  ): ConfirmInfraRegistrationResponse!
  """
  Disconnects an infra and deletes its configuration from the control plane
  """
  deleteInfra(projectID: ID!, infraID: String!): String! @authorized

  """
  Fetches manifest details
  """
  getManifestWithInfraID(
    projectID: ID!
    infraID: String!
    accessKey: String!
  ): String!

  """
  Receives pod logs for experiments from infra
  """
  # authorized directive not required
  podLog(request: PodLog!): String!

  """
  Receives kubernetes object data from subscriber
  """
  # authorized directive not required
  kubeObj(request: KubeObjectData!): String!
}

extend type Subscription {
  # INFRA OPERATIONS
  """
  Listens infra events from the graphql server
  """
  getInfraEvents(projectID: String!): InfraEventResponse! @authorized

  """
  Listens infra operation request from the graphql server
  """
  # authorized directive not required
  infraConnect(request: InfraIdentity!): InfraActionResponse!

  """
  Returns experiment logs from the pods
  """
  getPodLog(request: PodLogRequest!): PodLogResponse!

  # K8S OPERATIONS
  """
  Returns a kubernetes object given an input
  """
  getKubeObject(request: KubeObjectRequest!): KubeObjectResponse!
}
`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/chaoshub.graphqls", Input: `enum AuthType {
  BASIC
  NONE
  SSH
  TOKEN
}

enum FileType {
  EXPERIMENT
  ENGINE
  WORKFLOW
  CSV
}

enum HubType {
  GIT
  REMOTE
}

type ChaosHub implements ResourceDetails & Audit {
  """
  ID of the chaos hub
  """
  id: ID!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  ID of the project in which the chaos hub is present
  """
  projectID: ID!
  """
  Default Hub Identifier
  """
  isDefault: Boolean!
  """
  Name of the chaos hub
  """
  name: String!
  """
  Tags of the ChaosHub
  """
  tags: [String!]
  """
  User who created the ChaosHub
  """
  createdBy: UserDetails
  """
  User who has updated the ChaosHub
  """
  updatedBy: UserDetails
  """
  Description of ChaosHub
  """
  description: String
  """
  Type of ChaosHub
  """
  hubType: HubType!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Bool value indicating if the chaos hub is removed
  """
  isRemoved: Boolean!
  """
  Timestamp when the chaos hub was created
  """
  createdAt: String!
  """
  Timestamp when the chaos hub was last updated
  """
  updatedAt: String!
  """
  Timestamp when the chaos hub was last synced
  """
  lastSyncedAt: String!
}

#type Charts {
#	charts: [Chart!]!
#}

type Chart {
  apiVersion: String!
  kind: String!
  metadata: Metadata!
  spec: Spec!
  packageInfo: PackageInformation!
}

"""
Defines the details of the maintainer
"""
type Maintainer {
  """
  Name of the maintainer
  """
  name: String!
  """
  Email of the maintainer
  """
  email: String!
}

type Link {
  name: String!
  url: String!
}

type Metadata {
  name: String!
  version: String!
  annotations: Annotation!
}

type Annotation {
  categories: String!
  vendor: String!
  createdAt: String!
  repository: String!
  support: String!
  chartDescription: String!
}

type FaultList{
  name: String!
  displayName: String!
  description: String!
  plan: [String!]
}

type Spec {
  displayName: String!
  categoryDescription: String!
  keywords: [String!]!
  maturity: String!
  maintainers: [Maintainer!]!
  minKubeVersion: String!
  provider: Provider!
  links: [Link!]!
  faults: [FaultList!]!
  experiments: [String!]
  chaosExpCRDLink: String!
  platforms: [String!]!
  chaosType: String
}

type Provider {
	name: String!
}

type PackageInformation {
  packageName: String!
  experiments: [Experiments!]!
}

type Experiments {
  name: String!
  CSV: String!
  desc: String!
}

type ChaosHubStatus implements ResourceDetails & Audit {
  """
  ID of the hub
  """
  id: ID!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is available or not.
  """
  isAvailable: Boolean!
  """
  Total number of experiments in the hub
  """
  totalFaults: String!
  """
  Total experiments
  """
  totalExperiments: String!
  """
  Name of the chaos hub
  """
  name: String!
  """
  Type of ChaosHub
  """
  hubType: HubType!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Bool value indicating whether the hub is private or not.
  """
  isRemoved: Boolean!
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
  """
  Timestamp when the chaos hub was last synced
  """
  lastSyncedAt: String!
  """
  Tags of the ChaosHub
  """
  tags: [String!]
  """
  User who created the ChaosHub
  """
  createdBy: UserDetails
  """
  User who has updated the ChaosHub
  """
  updatedBy: UserDetails
  """
  Created at timestamp
  """
  createdAt: String!
  """
  Updated at timestamp
  """
  updatedAt: String!
  """
  Description of ChaosHub
  """
  description: String
  """
  Default Hub Identifier
  """
  isDefault: Boolean!
}

"""
Defines the details required for creating a chaos hub
"""
input CreateChaosHubRequest {
  """
  Name of the chaos hub
  """
  name: String!
  """
  Tags of the ChaosHub
  """
  tags: [String!]
  """
  Description of ChaosHub
  """
  description: String
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
}

input ExperimentRequest {
  """
  Name of the chart being used
  """
  category: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  ID of the hub
  """
  hubID: String!
}

input CloningInput {
  """
  Name of the chaos hub
  """
  name: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  sshPrivateKey: String
  isDefault:Boolean!
}

input CreateRemoteChaosHub {
  """
  Name of the chaos hub
  """
  name: String!
  """
  Tags of the ChaosHub
  """
  tags: [String!]
  """
  Description of ChaosHub
  """
  description: String
  """
  URL of the git repository
  """
  repoURL: String!
}


input UpdateChaosHubRequest {
  """
  ID of the chaos hub
  """
  id: String!
  """
  Name of the chaos hub
  """
  name: String!
  """
  Description of the infra
  """
  description: String
  """
  Tags of the infra
  """
  tags: [String!]
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
}

type ExperimentDetails{
  """
  Engine Manifest
  """
  engineDetails: String!

  """
  Experiment Manifest
  """
  experimentDetails: String!
}

type PredefinedExperimentList {
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Experiment CSV
  """
  experimentCSV: String!
  """
  Experiment Manifest
  """
  experimentManifest: String!
}

"""
Defines filter options for ChaosHub
"""
input ChaosHubFilterInput {
  """
  Name of the ChaosHub
  """
  chaosHubName: String
  """
  Tags of a chaos hub
  """
  tags: [String!]
  """
  Description of a chaos hub
  """
  description: String
}

input ListChaosHubRequest {
  """
  Array of ChaosHub IDs for which details will be fetched
  """
  chaosHubIDs: [ID!]
  """
  Details for fetching filtered data
  """
  filter: ChaosHubFilterInput
}

"""
Fault Detail consists of all the fault related details
"""
type FaultDetails {
  """
  fault consists of fault.yaml
  """
  fault: String!
  """
  engine consists engine.yaml
  """
  engine: String!
  """
  csv consists chartserviceversion.yaml
  """
  csv: String!
}

type GetChaosHubStatsResponse{
  """
  Total number of chaoshubs
  """
  totalChaosHubs: Int!

}


extend type Query {
  # CHAOS-HUB OPERATIONS
  """
  List the Charts details of a ChaosHub
  """
  listChaosFaults(hubID: ID!, projectID: ID!): [Chart!]! @authorized

  """
  Get the fault list from a ChaosHub
  """
  getChaosFault(projectID: ID!,request: ExperimentRequest!): FaultDetails! @authorized

  """
  Lists all the connected ChaosHub
  """
  listChaosHub(projectID: ID!, request: ListChaosHubRequest): [ChaosHubStatus]! @authorized
  """
  Get the details of a requested ChaosHub
  """
  getChaosHub(projectID: ID!, chaosHubID: ID!): ChaosHubStatus! @authorized
#
#  """
#  Get the YAML manifest of ChaosEngine/ChaosExperiment
#  """
#  getYAMLData(projectID: String!,request: ExperimentRequest!): String! @authorized

#  """
#  Get Engine and Experiment YAML
#  """
#  getExperimentDetails(projectID: String!,request: ExperimentRequest!): ExperimentDetails! @authorized

  """
  List the PredefinedExperiments present in the hub
  """
  listPredefinedExperiments(hubID: ID!, projectID: ID!): [PredefinedExperimentList!]! @authorized
  """
  Returns predefined experiment details of selected experiments
  """
  getPredefinedExperiment(
    hubID: ID!
    experimentName: [String!]!
    projectID: ID!
  ): [PredefinedExperimentList!]! @authorized
  """
  Query to get experiment stats
  """
  getChaosHubStats(projectID: ID!): GetChaosHubStatsResponse!  @authorized
}

extend type Mutation {
  # CHAOS-HUB OPERATIONS
  """
  Add a ChaosHub (includes the git clone operation)
  """
  addChaosHub(  projectID: ID!,request: CreateChaosHubRequest!): ChaosHub! @authorized

  """
  Add a ChaosHub (remote hub download)
  """
  addRemoteChaosHub(projectID: ID!,request: CreateRemoteChaosHub!): ChaosHub! @authorized

  """
  Save a ChaosHub configuration without cloning it
  """
  saveChaosHub(projectID: ID!,request: CreateChaosHubRequest!): ChaosHub! @authorized

  """
  Sync changes from the Git repository of a ChaosHub
  """
  syncChaosHub(id: ID!, projectID: ID!): String! @authorized

  """
  Generates Private and Public key for SSH authentication
  """
  generateSSHKey: SSHKey! @authorized

  """
  Update the configuration of a ChaosHub
  """
  updateChaosHub(projectID: ID!,request: UpdateChaosHubRequest!): ChaosHub! @authorized

  """
  Delete the ChaosHub
  """
  deleteChaosHub(projectID: ID!, hubID: ID!): Boolean! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/common.graphqls", Input: `
interface ResourceDetails {
    name: String!
    description: String
    tags:[String!]
}

interface Audit {
    updatedAt: String
    createdAt: String
    updatedBy: UserDetails
    createdBy: UserDetails
}

type UserDetails {
    userID: String!
    username: String!
    email: String!
}

`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/environment.graphqls", Input: `
enum EnvironmentType{
    PROD
    NON_PROD
}

type Environment implements ResourceDetails & Audit {
    projectID:String!
    environmentID : String!
    name: String!
    description: String
    tags:[String!]
    type: EnvironmentType!
    createdAt: String!
    createdBy: UserDetails
    updatedBy: UserDetails
    updatedAt: String!
    isRemoved: Boolean
    infraIDs:[String!]
}

input CreateEnvironmentRequest{
    environmentID : String! #check if human readable ID is required
    name: String!
    type: EnvironmentType!
    description: String
    tags:[String!]
}

input UpdateEnvironmentRequest{
    environmentID : String!
    name: String
    description: String
    tags:[String]
    type: EnvironmentType
}

"""
Defines filter options for infras
"""
input EnvironmentFilterInput {
    """
    Name of the environment
    """
    name: String
    """
    ID of the environment
    """
    description: String
    """
    Type name of environment
    """
    type: String
    """
    Tags of an environment
    """
    tags: [EnvironmentType]
}
enum EnvironmentSortingField {
    NAME
    TIME
}

"""
Defines sorting options for experiment
"""
input EnvironmentSortInput {
    """
    Field in which sorting will be done
    """
    field: EnvironmentSortingField!
    """
    Bool value indicating whether the sorting will be done in ascending order
    """
    ascending: Boolean
}


input ListEnvironmentRequest{
    """
    Environment ID
    """
    environmentIDs: [ID!]
    """
    Details for fetching paginated data
    """
    pagination: Pagination
    """
    Details for fetching filtered data
    """
    filter: EnvironmentFilterInput
    """
    Details for fetching sorted data
    """
    sort: EnvironmentSortInput
}

type ListEnvironmentResponse{
    """
    Total number of environment
    """
    totalNoOfEnvironments: Int!
    environments:[Environment]
}

extend type Query {

    getEnvironment(projectID: ID!, environmentID: ID!) : Environment @authorized
    listEnvironments (projectID: ID!, request: ListEnvironmentRequest): ListEnvironmentResponse @authorized
}

extend type Mutation{
    createEnvironment( projectID:ID!,request:CreateEnvironmentRequest): Environment @authorized
    updateEnvironment( projectID:ID!,request:UpdateEnvironmentRequest): String! @authorized
    deleteEnvironment(projectID:ID!,environmentID: ID!): String! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/gitops.graphqls", Input: `
"""
Defines the SSHKey details
"""
type SSHKey {
    """
    Public SSH key authenticating into git repository
    """
    publicKey: String!
    """
    Private SSH key authenticating into git repository
    """
    privateKey: String!
}

"""
Details of setting a Git repository
"""
input GitConfig {
    """
    ID of the project where GitOps is configured
    """
    projectID: ID!
    """
    Git branch where the chaos charts will be pushed and synced
    """
    branch: String!
    """
    URL of the Git repository
    """
    repoURL: String!
    """
    Type of authentication used: 	BASIC, SSH,	TOKEN
    """
    authType: AuthType!
    """
    Token used for private repository
    """
    token: String
    """
    Git username
    """
    userName: String
    """
    Git password
    """
    password: String
    """
    Private SSH key authenticating into git repository
    """
    sshPrivateKey: String
}

"""
Response received after configuring GitOps
"""
type GitConfigResponse {
    """
    Bool value indicating whether GitOps is enabled or not
    """
    enabled: Boolean!
    """
    ID of the project where GitOps is configured
    """
    projectID: String!
    """
    Git branch where the chaos charts will be pushed and synced
    """
    branch: String
    """
    URL of the Git repository
    """
    repoURL: String
    """
    Type of authentication used: 	BASIC, SSH,	TOKEN
    """
    authType: AuthType
    """
    Token used for private repository
    """
    token: String
    """
    Git username
    """
    userName: String
    """
    Git password
    """
    password: String
    """
    Private SSH key authenticating into git repository
    """
    sshPrivateKey: String
}

extend type Query {
    # GIT-OPS OPERATIONS
    """
    Returns the git configuration for gitops
    """
    getGitOpsDetails(projectID: ID!): GitConfigResponse! @authorized
}

extend type Mutation {
    # GIT-OPS OPERATIONS
    """
    Sends workflow run request(single run workflow only) to agent on gitops notification
    """
    # authorized directive not required
    gitopsNotifier(clusterInfo: InfraIdentity!, experimentID: ID!): String!

    """
    Enables gitops settings in the project
    """
    enableGitOps(configurations: GitConfig!): Boolean! @authorized

    """
    Disables gitops settings in the project
    """
    disableGitOps(projectID: String!): Boolean! @authorized

    """
    Updates gitops settings in the project
    """
    updateGitOps(configurations: GitConfig!): Boolean! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/image_registry.graphqls", Input: `"""
Defines details for image registry
"""
type ImageRegistry {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean
  """
  Name of Image Registry
  """
  imageRegistryName: String!
  """
  Name of image repository
  """
  imageRepoName: String!
  """
  Type of the image registry: public/private
  """
  imageRegistryType: String!
  """
  Secret which is used for private registry
  """
  secretName: String
  """
  Namespace where the secret is available
  """
  secretNamespace: String
  """
  Bool value indicating if image registry is enabled or not
  """
  enableRegistry: Boolean
}

"""
Defines input data for querying the details of an image registry
"""
input ImageRegistryInput {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean!
  """
  Name of Image Registry
  """
  imageRegistryName: String!
  """
  Name of image repository
  """
  imageRepoName: String!
  """
  Type of the image registry: public/private
  """
  imageRegistryType: String!
  """
  Secret which is used for private registry
  """
  secretName: String
  """
  Namespace where the secret is available
  """
  secretNamespace: String
  """
  Bool value indicating if image registry is enabled or not
  """
  enableRegistry: Boolean
}

"""
Defines response data for image registry
"""
type ImageRegistryResponse implements Audit {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean!
  """
  Information Image Registry
  """
  imageRegistryInfo: ImageRegistry
  """
  ID of the image registry
  """
  imageRegistryID: String!
  """
  ID of the project in which image registry is created
  """
  projectID: String!
  """
  Timestamp when the image registry was last updated
  """
  updatedAt: String
  """
  Timestamp when the image registry was created
  """
  createdAt: String
  """
  User who created the infra
  """
  createdBy: UserDetails
  """
  User who has updated the infra
  """
  updatedBy: UserDetails
  """
  Bool value indicating if the image registry has been removed
  """
  isRemoved: Boolean
}

extend type Query {
  # IMAGE REGISTRY OPERATIONS
  listImageRegistry(projectID: String!): [ImageRegistryResponse!] @authorized

  getImageRegistry(
    imageRegistryID: String!
    projectID: String!
  ): ImageRegistryResponse! @authorized
}

extend type Mutation {
  # IMAGE REGISTRY OPERATIONS
  """
  Create an Image Registry configuration
  """
  createImageRegistry(
    projectID: String!
    imageRegistryInfo: ImageRegistryInput!
  ): ImageRegistryResponse! @authorized

  """
  Update the Image Registry configuration
  """
  updateImageRegistry(
    imageRegistryID: String!
    projectID: String!
    imageRegistryInfo: ImageRegistryInput!
  ): ImageRegistryResponse! @authorized

  """
  Delete the Image Registry
  """
  deleteImageRegistry(imageRegistryID: String!, projectID: String!): String!
  @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "../definitions/shared/project.graphqls", Input: `enum Invitation {
  Accepted
  Pending
}

enum MemberRole {
  Owner
  Editor
  Viewer
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.CreateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNCreateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐCreateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addRemoteChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.CreateRemoteChaosHub
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNCreateRemoteChaosHub2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐCreateRemoteChaosHub(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_chaosExperimentRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRunRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRunRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmInfraRegistration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.InfraIdentity
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNInfraIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ChaosExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNChaosExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.CreateEnvironmentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOCreateEnvironmentRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐCreateEnvironmentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ImageRegistryInput
	if tmp, ok := rawArgs["imageRegistryInfo"]; ok {
		arg1, err = ec.unmarshalNImageRegistryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryInfo"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["experimentID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["experimentRunID"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentRunID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg2, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["environmentID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["environmentID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteInfra_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_disableGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_enableGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GitConfig
	if tmp, ok := rawArgs["configurations"]; ok {
		arg0, err = ec.unmarshalNGitConfig2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGitConfig(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["configurations"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_getManifestWithInfraID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["accessKey"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accessKey"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_gitopsNotifier_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.InfraIdentity
	if tmp, ok := rawArgs["clusterInfo"]; ok {
		arg0, err = ec.unmarshalNInfraIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterInfo"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["experimentID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_kubeObj_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.KubeObjectData
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNKubeObjectData2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObjectData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_podLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PodLog
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNPodLog2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPodLog(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerInfra_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.RegisterInfraRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNRegisterInfraRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRegisterInfraRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_runChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["experimentID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SaveChaosExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNSaveChaosExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐSaveChaosExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.CreateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNCreateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐCreateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_syncChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChaosExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ChaosExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOChaosExperimentRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.UpdateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNUpdateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUpdateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.UpdateEnvironmentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOUpdateEnvironmentRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUpdateEnvironmentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GitConfig
	if tmp, ok := rawArgs["configurations"]; ok {
		arg0, err = ec.unmarshalNGitConfig2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGitConfig(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["configurations"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	var arg2 model.ImageRegistryInput
	if tmp, ok := rawArgs["imageRegistryInfo"]; ok {
		arg2, err = ec.unmarshalNImageRegistryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryInfo"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getChaosFault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getChaosHubStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["chaosHubID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chaosHubID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["environmentID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["environmentID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getExperimentRunStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getExperimentRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["experimentRunID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentRunID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getExperimentStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["experimentID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getGitOpsDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getInfraDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getInfraManifest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["upgrade"]; ok {
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upgrade"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg2, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getInfraStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getInfra_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["infraID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["infraID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getPredefinedExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["experimentName"]; ok {
		arg1, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["experimentName"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg2, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getVersionDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listChaosFaults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.ListChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOListChaosHubRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listEnvironments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.ListEnvironmentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOListEnvironmentRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListEnvironmentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listExperimentRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ListExperimentRunRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNListExperimentRunRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentRunRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ListExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalNListExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listInfras_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *model.ListInfraRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg1, err = ec.unmarshalOListInfraRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListInfraRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listPredefinedExperiments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_getInfraEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getKubeObject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.KubeObjectRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNKubeObjectRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObjectRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getPodLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PodLogRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNPodLogRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPodLogRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_infraConnect_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.InfraIdentity
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNInfraIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActionPayload_requestID(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_requestType(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_k8sManifest(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.K8sManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_namespace(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_externalData(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_username(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_categories(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Categories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_vendor(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vendor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_repository(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_support(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Support, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_chartDescription(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChartDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_experimentID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_cronSyntax(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CronSyntax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_experimentName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_experimentDescription(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_isCustomExperiment(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomExperiment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosExperimentResponse_tags(ctx context.Context, field graphql.CollectedField, obj *model.ChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_id(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_repoBranch(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_name(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_tags(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_description(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_hubType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HubType)
	fc.Result = res
	return ec.marshalNHubType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐHubType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isPrivate(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrivate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_authType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthType)
	fc.Result = res
	return ec.marshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_token(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_userName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_password(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_lastSyncedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_id(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_repoBranch(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isAvailable(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_totalFaults(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalFaults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_totalExperiments(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_name(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_hubType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HubType)
	fc.Result = res
	return ec.marshalNHubType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐHubType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isPrivate(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrivate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_authType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthType)
	fc.Result = res
	return ec.marshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_token(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_userName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_password(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_sshPublicKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_lastSyncedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_tags(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_description(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_kind(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Metadata)
	fc.Result = res
	return ec.marshalNMetadata2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_spec(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Spec)
	fc.Result = res
	return ec.marshalNSpec2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_packageInfo(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PackageInformation)
	fc.Result = res
	return ec.marshalNPackageInformation2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPackageInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmInfraRegistrationResponse_isInfraConfirmed(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmInfraRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmInfraRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInfraConfirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmInfraRegistrationResponse_newAccessKey(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmInfraRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmInfraRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewAccessKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmInfraRegistrationResponse_infraID(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmInfraRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmInfraRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_environmentID(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_name(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_description(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_tags(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_type(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EnvironmentType)
	fc.Result = res
	return ec.marshalNEnvironmentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _Environment_infraIDs(ctx context.Context, field graphql.CollectedField, obj *model.Environment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Environment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_experimentID(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_experimentType(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_experimentManifest(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_cronSyntax(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CronSyntax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_name(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_description(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_weightages(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Weightages)
	fc.Result = res
	return ec.marshalNWeightages2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightagesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_isCustomExperiment(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomExperiment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_infra(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Infra, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalOInfra2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_tags(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_recentExperimentRunDetails(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecentExperimentRunDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RecentExperimentRun)
	fc.Result = res
	return ec.marshalORecentExperimentRun2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRecentExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.Experiment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentDetails_engineDetails(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EngineDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentDetails_experimentDetails(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentRunID(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentType(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentID(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_weightages(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Weightages)
	fc.Result = res
	return ec.marshalNWeightages2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightagesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_infra(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Infra, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentName(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentManifest(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_phase(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ExperimentRunStatus)
	fc.Result = res
	return ec.marshalNExperimentRunStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_resiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsPassed(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsPassed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsFailed(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsFailed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsAwaited(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsAwaited, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsStopped(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsStopped, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_faultsNa(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultsNa, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_totalFaults(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalFaults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_executionData(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutionData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_name(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_CSV(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Csv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_desc(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultDetails_fault(ctx context.Context, field graphql.CollectedField, obj *model.FaultDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultDetails_engine(ctx context.Context, field graphql.CollectedField, obj *model.FaultDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Engine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultDetails_csv(ctx context.Context, field graphql.CollectedField, obj *model.FaultDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Csv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultList_name(ctx context.Context, field graphql.CollectedField, obj *model.FaultList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultList_displayName(ctx context.Context, field graphql.CollectedField, obj *model.FaultList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultList_description(ctx context.Context, field graphql.CollectedField, obj *model.FaultList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FaultList_plan(ctx context.Context, field graphql.CollectedField, obj *model.FaultList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FaultList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _GetChaosHubStatsResponse_totalChaosHubs(ctx context.Context, field graphql.CollectedField, obj *model.GetChaosHubStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetChaosHubStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalChaosHubs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentResponse_experimentDetails(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Experiment)
	fc.Result = res
	return ec.marshalNExperiment2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiment(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentResponse_averageResiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AverageResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalCompletedExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCompletedExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalTerminatedExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTerminatedExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalRunningExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalRunningExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalStoppedExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalStoppedExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentRunStatsResponse_totalErroredExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalErroredExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentStatsResponse_totalExperiments(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetExperimentStatsResponse_totalExpCategorizedByResiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.GetExperimentStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetExperimentStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExpCategorizedByResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ResilienceScoreCategory)
	fc.Result = res
	return ec.marshalNResilienceScoreCategory2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐResilienceScoreCategory(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalInfrastructures(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalInfrastructures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalActiveInfrastructure(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalActiveInfrastructure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalInactiveInfrastructures(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalInactiveInfrastructures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalConfirmedInfrastructure(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalConfirmedInfrastructure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GetInfraStatsResponse_totalNonConfirmedInfrastructures(ctx context.Context, field graphql.CollectedField, obj *model.GetInfraStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GetInfraStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNonConfirmedInfrastructures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_enabled(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_branch(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_authType(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AuthType)
	fc.Result = res
	return ec.marshalOAuthType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_token(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_userName(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_password(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRegistryName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRepoName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRepoName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRegistryType(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_secretName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_secretNamespace(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_enableRegistry(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnableRegistry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_imageRegistryInfo(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistry)
	fc.Result = res
	return ec.marshalOImageRegistry2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_imageRegistryID(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraID(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_name(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_description(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_tags(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_environmentID(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_platformName(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlatformName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_isActive(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_isInfraConfirmed(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInfraConfirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_noOfExperiments(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_noOfExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_token(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraNamespace(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraScope(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraScope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraNsExists(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraNsExists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraSaExists(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraSaExists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_lastExperimentTimestamp(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastExperimentTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_startTime(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_version(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_infraType(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.InfrastructureType)
	fc.Result = res
	return ec.marshalOInfrastructureType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx, field.Selections, res)
}

func (ec *executionContext) _Infra_updateStatus(ctx context.Context, field graphql.CollectedField, obj *model.Infra) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Infra",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateStatus)
	fc.Result = res
	return ec.marshalNUpdateStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUpdateStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraActionResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.InfraActionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraActionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraActionResponse_action(ctx context.Context, field graphql.CollectedField, obj *model.InfraActionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraActionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ActionPayload)
	fc.Result = res
	return ec.marshalNActionPayload2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐActionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_eventID(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_eventType(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_eventName(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_description(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraEventResponse_infra(ctx context.Context, field graphql.CollectedField, obj *model.InfraEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Infra, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraVersionDetails_latestVersion(ctx context.Context, field graphql.CollectedField, obj *model.InfraVersionDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraVersionDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InfraVersionDetails_compatibleVersions(ctx context.Context, field graphql.CollectedField, obj *model.InfraVersionDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InfraVersionDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompatibleVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObject_namespace(ctx context.Context, field graphql.CollectedField, obj *model.KubeObject) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObject",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObject_data(ctx context.Context, field graphql.CollectedField, obj *model.KubeObject) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObject",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ObjectData)
	fc.Result = res
	return ec.marshalNObjectData2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐObjectData(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObjectResponse_infraID(ctx context.Context, field graphql.CollectedField, obj *model.KubeObjectResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObjectResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObjectResponse_kubeObj(ctx context.Context, field graphql.CollectedField, obj *model.KubeObjectResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObjectResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KubeObj, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.KubeObject)
	fc.Result = res
	return ec.marshalNKubeObject2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObject(ctx, field.Selections, res)
}

func (ec *executionContext) _Link_name(ctx context.Context, field graphql.CollectedField, obj *model.Link) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Link",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Link_url(ctx context.Context, field graphql.CollectedField, obj *model.Link) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Link",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListEnvironmentResponse_totalNoOfEnvironments(ctx context.Context, field graphql.CollectedField, obj *model.ListEnvironmentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListEnvironmentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfEnvironments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListEnvironmentResponse_environments(ctx context.Context, field graphql.CollectedField, obj *model.ListEnvironmentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListEnvironmentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) _ListExperimentResponse_totalNoOfExperiments(ctx context.Context, field graphql.CollectedField, obj *model.ListExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListExperimentResponse_experiments(ctx context.Context, field graphql.CollectedField, obj *model.ListExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Experiment)
	fc.Result = res
	return ec.marshalNExperiment2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiment(ctx, field.Selections, res)
}

func (ec *executionContext) _ListExperimentRunResponse_totalNoOfExperimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.ListExperimentRunResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListExperimentRunResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListExperimentRunResponse_experimentRuns(ctx context.Context, field graphql.CollectedField, obj *model.ListExperimentRunResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListExperimentRunResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ExperimentRun)
	fc.Result = res
	return ec.marshalNExperimentRun2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _ListInfraResponse_totalNoOfInfras(ctx context.Context, field graphql.CollectedField, obj *model.ListInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfInfras, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListInfraResponse_infras(ctx context.Context, field graphql.CollectedField, obj *model.ListInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Infras, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_name(ctx context.Context, field graphql.CollectedField, obj *model.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_email(ctx context.Context, field graphql.CollectedField, obj *model.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_name(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_version(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_annotations(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Annotation)
	fc.Result = res
	return ec.marshalNAnnotation2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAnnotation(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateChaosExperiment(rctx, args["request"].(model.ChaosExperimentRequest), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosExperimentResponse)
	fc.Result = res
	return ec.marshalNChaosExperimentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_saveChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_saveChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveChaosExperiment(rctx, args["request"].(model.SaveChaosExperimentRequest), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_runChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_runChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RunChaosExperiment(rctx, args["experimentID"].(string), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RunChaosExperimentResponse)
	fc.Result = res
	return ec.marshalNRunChaosExperimentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRunChaosExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateChaosExperiment(rctx, args["request"].(*model.ChaosExperimentRequest), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosExperimentResponse)
	fc.Result = res
	return ec.marshalNChaosExperimentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChaosExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChaosExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteChaosExperiment(rctx, args["experimentID"].(string), args["experimentRunID"].(*string), args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_chaosExperimentRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_chaosExperimentRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ChaosExperimentRun(rctx, args["request"].(model.ExperimentRunRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_registerInfra(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_registerInfra_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RegisterInfra(rctx, args["projectID"].(string), args["request"].(model.RegisterInfraRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RegisterInfraResponse)
	fc.Result = res
	return ec.marshalNRegisterInfraResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRegisterInfraResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_confirmInfraRegistration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_confirmInfraRegistration_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmInfraRegistration(rctx, args["request"].(model.InfraIdentity))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConfirmInfraRegistrationResponse)
	fc.Result = res
	return ec.marshalNConfirmInfraRegistrationResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐConfirmInfraRegistrationResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteInfra(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteInfra_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteInfra(rctx, args["projectID"].(string), args["infraID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_getManifestWithInfraID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_getManifestWithInfraID_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetManifestWithInfraID(rctx, args["projectID"].(string), args["infraID"].(string), args["accessKey"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_podLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_podLog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PodLog(rctx, args["request"].(model.PodLog))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_kubeObj(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_kubeObj_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().KubeObj(rctx, args["request"].(model.KubeObjectData))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddChaosHub(rctx, args["projectID"].(string), args["request"].(model.CreateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addRemoteChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addRemoteChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddRemoteChaosHub(rctx, args["projectID"].(string), args["request"].(model.CreateRemoteChaosHub))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_saveChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_saveChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SaveChaosHub(rctx, args["projectID"].(string), args["request"].(model.CreateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_syncChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_syncChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SyncChaosHub(rctx, args["id"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_generateSSHKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().GenerateSSHKey(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SSHKey); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.SSHKey`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SSHKey)
	fc.Result = res
	return ec.marshalNSSHKey2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐSSHKey(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateChaosHub(rctx, args["projectID"].(string), args["request"].(model.UpdateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteChaosHub(rctx, args["projectID"].(string), args["hubID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createEnvironment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEnvironment(rctx, args["projectID"].(string), args["request"].(*model.CreateEnvironmentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateEnvironment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEnvironment(rctx, args["projectID"].(string), args["request"].(*model.UpdateEnvironmentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteEnvironment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEnvironment(rctx, args["projectID"].(string), args["environmentID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_gitopsNotifier(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_gitopsNotifier_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GitopsNotifier(rctx, args["clusterInfo"].(model.InfraIdentity), args["experimentID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_enableGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_enableGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().EnableGitOps(rctx, args["configurations"].(model.GitConfig))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_disableGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_disableGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DisableGitOps(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateGitOps(rctx, args["configurations"].(model.GitConfig))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateImageRegistry(rctx, args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ObjectData_labels(ctx context.Context, field graphql.CollectedField, obj *model.ObjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ObjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ObjectData_name(ctx context.Context, field graphql.CollectedField, obj *model.ObjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ObjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageInformation_packageName(ctx context.Context, field graphql.CollectedField, obj *model.PackageInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PackageInformation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageInformation_experiments(ctx context.Context, field graphql.CollectedField, obj *model.PackageInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PackageInformation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Experiments)
	fc.Result = res
	return ec.marshalNExperiments2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_experimentRunID(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_podName(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_podType(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_log(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Log, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedExperimentList_experimentName(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedExperimentList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedExperimentList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedExperimentList_experimentCSV(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedExperimentList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedExperimentList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentCsv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedExperimentList_experimentManifest(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedExperimentList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedExperimentList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Provider_name(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Provider",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperimentRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperimentRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetExperimentRun(rctx, args["projectID"].(string), args["experimentRunID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ExperimentRun)
	fc.Result = res
	return ec.marshalNExperimentRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listExperimentRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listExperimentRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListExperimentRun(rctx, args["projectID"].(string), args["request"].(model.ListExperimentRunRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListExperimentRunResponse)
	fc.Result = res
	return ec.marshalNListExperimentRunResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentRunResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetExperiment(rctx, args["projectID"].(string), args["experimentID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetExperimentResponse)
	fc.Result = res
	return ec.marshalNGetExperimentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListExperiment(rctx, args["projectID"].(string), args["request"].(model.ListExperimentRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListExperimentResponse)
	fc.Result = res
	return ec.marshalNListExperimentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperimentRunStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperimentRunStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetExperimentRunStats(rctx, args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetExperimentRunStatsResponse)
	fc.Result = res
	return ec.marshalNGetExperimentRunStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetExperimentRunStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperimentStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperimentStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetExperimentStats(rctx, args["projectID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetExperimentStatsResponse)
	fc.Result = res
	return ec.marshalNGetExperimentStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetExperimentStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getInfra(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getInfra_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInfra(rctx, args["projectID"].(string), args["infraID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Infra); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Infra`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listInfras(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listInfras_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListInfras(rctx, args["projectID"].(string), args["request"].(*model.ListInfraRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListInfraResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ListInfraResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListInfraResponse)
	fc.Result = res
	return ec.marshalNListInfraResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListInfraResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getInfraDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getInfraDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInfraDetails(rctx, args["infraID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Infra); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Infra`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Infra)
	fc.Result = res
	return ec.marshalNInfra2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getInfraManifest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getInfraManifest_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInfraManifest(rctx, args["infraID"].(string), args["upgrade"].(bool), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getInfraStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getInfraStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInfraStats(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GetInfraStatsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.GetInfraStatsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetInfraStatsResponse)
	fc.Result = res
	return ec.marshalNGetInfraStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetInfraStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getVersionDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getVersionDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetVersionDetails(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.InfraVersionDetails); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.InfraVersionDetails`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.InfraVersionDetails)
	fc.Result = res
	return ec.marshalNInfraVersionDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraVersionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getServerVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetServerVersion(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ServerVersionResponse)
	fc.Result = res
	return ec.marshalNServerVersionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐServerVersionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listChaosFaults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listChaosFaults_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListChaosFaults(rctx, args["hubID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Chart); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Chart`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Chart)
	fc.Result = res
	return ec.marshalNChart2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChartᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getChaosFault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getChaosFault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetChaosFault(rctx, args["projectID"].(string), args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.FaultDetails); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.FaultDetails`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FaultDetails)
	fc.Result = res
	return ec.marshalNFaultDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐFaultDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListChaosHub(rctx, args["projectID"].(string), args["request"].(*model.ListChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ChaosHubStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHubStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChaosHubStatus)
	fc.Result = res
	return ec.marshalNChaosHubStatus2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetChaosHub(rctx, args["projectID"].(string), args["chaosHubID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHubStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ChaosHubStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHubStatus)
	fc.Result = res
	return ec.marshalNChaosHubStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listPredefinedExperiments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listPredefinedExperiments_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListPredefinedExperiments(rctx, args["hubID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PredefinedExperimentList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.PredefinedExperimentList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PredefinedExperimentList)
	fc.Result = res
	return ec.marshalNPredefinedExperimentList2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPredefinedExperimentListᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPredefinedExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPredefinedExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPredefinedExperiment(rctx, args["hubID"].(string), args["experimentName"].([]string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PredefinedExperimentList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.PredefinedExperimentList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PredefinedExperimentList)
	fc.Result = res
	return ec.marshalNPredefinedExperimentList2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPredefinedExperimentListᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getChaosHubStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getChaosHubStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetChaosHubStats(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GetChaosHubStatsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.GetChaosHubStatsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GetChaosHubStatsResponse)
	fc.Result = res
	return ec.marshalNGetChaosHubStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetChaosHubStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getEnvironment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEnvironment(rctx, args["projectID"].(string), args["environmentID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listEnvironments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listEnvironments_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListEnvironments(rctx, args["projectID"].(string), args["request"].(*model.ListEnvironmentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListEnvironmentResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ListEnvironmentResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ListEnvironmentResponse)
	fc.Result = res
	return ec.marshalOListEnvironmentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListEnvironmentResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getGitOpsDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getGitOpsDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetGitOpsDetails(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GitConfigResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.GitConfigResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GitConfigResponse)
	fc.Result = res
	return ec.marshalNGitConfigResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGitConfigResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListImageRegistry(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalOImageRegistryResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryResponseᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_experimentRunID(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_phase(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_resiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _RecentExperimentRun_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.RecentExperimentRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RecentExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserDetails)
	fc.Result = res
	return ec.marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterInfraResponse_token(ctx context.Context, field graphql.CollectedField, obj *model.RegisterInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterInfraResponse_infraID(ctx context.Context, field graphql.CollectedField, obj *model.RegisterInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfraID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterInfraResponse_name(ctx context.Context, field graphql.CollectedField, obj *model.RegisterInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterInfraResponse_manifest(ctx context.Context, field graphql.CollectedField, obj *model.RegisterInfraResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterInfraResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ResilienceScoreCategory_id(ctx context.Context, field graphql.CollectedField, obj *model.ResilienceScoreCategory) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ResilienceScoreCategory",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ResilienceScoreCategory_count(ctx context.Context, field graphql.CollectedField, obj *model.ResilienceScoreCategory) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ResilienceScoreCategory",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _RunChaosExperimentResponse_notifyID(ctx context.Context, field graphql.CollectedField, obj *model.RunChaosExperimentResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RunChaosExperimentResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotifyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SSHKey_publicKey(ctx context.Context, field graphql.CollectedField, obj *model.SSHKey) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SSHKey",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SSHKey_privateKey(ctx context.Context, field graphql.CollectedField, obj *model.SSHKey) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SSHKey",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServerVersionResponse_key(ctx context.Context, field graphql.CollectedField, obj *model.ServerVersionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ServerVersionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServerVersionResponse_value(ctx context.Context, field graphql.CollectedField, obj *model.ServerVersionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ServerVersionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_displayName(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_categoryDescription(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CategoryDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_keywords(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_maturity(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maturity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_maintainers(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maintainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐMaintainerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_minKubeVersion(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinKubeVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_provider(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Provider)
	fc.Result = res
	return ec.marshalNProvider2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐProvider(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_links(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Links, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Link)
	fc.Result = res
	return ec.marshalNLink2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_faults(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FaultList)
	fc.Result = res
	return ec.marshalNFaultList2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐFaultListᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_experiments(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_chaosExpCRDLink(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosExpCRDLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_platforms(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platforms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_chaosType(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _StopExperimentRunsRequest_projectID(ctx context.Context, field graphql.CollectedField, obj *model.StopExperimentRunsRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "StopExperimentRunsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StopExperimentRunsRequest_experimentID(ctx context.Context, field graphql.CollectedField, obj *model.StopExperimentRunsRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "StopExperimentRunsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StopExperimentRunsRequest_experimentRunID(ctx context.Context, field graphql.CollectedField, obj *model.StopExperimentRunsRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "StopExperimentRunsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Subscription_getInfraEvents(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getInfraEvents_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetInfraEvents(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.InfraEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/chaoscenter/graphql/server/graph/model.InfraEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.InfraEventResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNInfraEventResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraEventResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_infraConnect(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_infraConnect_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().InfraConnect(rctx, args["request"].(model.InfraIdentity))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.InfraActionResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNInfraActionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraActionResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getPodLog(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getPodLog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().GetPodLog(rctx, args["request"].(model.PodLogRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.PodLogResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNPodLogResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPodLogResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getKubeObject(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getKubeObject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().GetKubeObject(rctx, args["request"].(model.KubeObjectRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.KubeObjectResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNKubeObjectResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObjectResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _UserDetails_userID(ctx context.Context, field graphql.CollectedField, obj *model.UserDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UserDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserDetails_username(ctx context.Context, field graphql.CollectedField, obj *model.UserDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UserDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserDetails_email(ctx context.Context, field graphql.CollectedField, obj *model.UserDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UserDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Weightages_faultName(ctx context.Context, field graphql.CollectedField, obj *model.Weightages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Weightages",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FaultName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Weightages_weightage(ctx context.Context, field graphql.CollectedField, obj *model.Weightages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Weightages",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputChaosExperimentRequest(ctx context.Context, obj interface{}) (model.ChaosExperimentRequest, error) {
	var it model.ChaosExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentID":
			var err error
			it.ExperimentID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "runExperiment":
			var err error
			it.RunExperiment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentManifest":
			var err error
			it.ExperimentManifest, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentType":
			var err error
			it.ExperimentType, err = ec.unmarshalOExperimentType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentType(ctx, v)
			if err != nil {
				return it, err
			}
		case "cronSyntax":
			var err error
			it.CronSyntax, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentDescription":
			var err error
			it.ExperimentDescription, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightages":
			var err error
			it.Weightages, err = ec.unmarshalNWeightagesInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightagesInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "isCustomExperiment":
			var err error
			it.IsCustomExperiment, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChaosHubFilterInput(ctx context.Context, obj interface{}) (model.ChaosHubFilterInput, error) {
	var it model.ChaosHubFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "chaosHubName":
			var err error
			it.ChaosHubName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCloningInput(ctx context.Context, obj interface{}) (model.CloningInput, error) {
	var it model.CloningInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isDefault":
			var err error
			it.IsDefault, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateChaosHubRequest(ctx context.Context, obj interface{}) (model.CreateChaosHubRequest, error) {
	var it model.CreateChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPublicKey":
			var err error
			it.SSHPublicKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEnvironmentRequest(ctx context.Context, obj interface{}) (model.CreateEnvironmentRequest, error) {
	var it model.CreateEnvironmentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "environmentID":
			var err error
			it.EnvironmentID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNEnvironmentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRemoteChaosHub(ctx context.Context, obj interface{}) (model.CreateRemoteChaosHub, error) {
	var it model.CreateRemoteChaosHub
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDateRange(ctx context.Context, obj interface{}) (model.DateRange, error) {
	var it model.DateRange
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "startDate":
			var err error
			it.StartDate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error
			it.EndDate, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvironmentFilterInput(ctx context.Context, obj interface{}) (model.EnvironmentFilterInput, error) {
	var it model.EnvironmentFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOEnvironmentType2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvironmentSortInput(ctx context.Context, obj interface{}) (model.EnvironmentSortInput, error) {
	var it model.EnvironmentSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNEnvironmentSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "ascending":
			var err error
			it.Ascending, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentFilterInput(ctx context.Context, obj interface{}) (model.ExperimentFilterInput, error) {
	var it model.ExperimentFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraName":
			var err error
			it.InfraName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraActive":
			var err error
			it.InfraActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "scheduleType":
			var err error
			it.ScheduleType, err = ec.unmarshalOScheduleType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐScheduleType(ctx, v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error
			it.Status, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateRange":
			var err error
			it.DateRange, err = ec.unmarshalODateRange2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐDateRange(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraTypes":
			var err error
			it.InfraTypes, err = ec.unmarshalOInfrastructureType2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRequest(ctx context.Context, obj interface{}) (model.ExperimentRequest, error) {
	var it model.ExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "category":
			var err error
			it.Category, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hubID":
			var err error
			it.HubID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRunFilterInput(ctx context.Context, obj interface{}) (model.ExperimentRunFilterInput, error) {
	var it model.ExperimentRunFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentType":
			var err error
			it.ExperimentType, err = ec.unmarshalOScheduleType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐScheduleType(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentStatus":
			var err error
			it.ExperimentStatus, err = ec.unmarshalOExperimentRunStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateRange":
			var err error
			it.DateRange, err = ec.unmarshalODateRange2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐDateRange(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunID":
			var err error
			it.ExperimentRunID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunStatus":
			var err error
			it.ExperimentRunStatus, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraTypes":
			var err error
			it.InfraTypes, err = ec.unmarshalOInfrastructureType2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRunRequest(ctx context.Context, obj interface{}) (model.ExperimentRunRequest, error) {
	var it model.ExperimentRunRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentID":
			var err error
			it.ExperimentID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "notifyID":
			var err error
			it.NotifyID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunID":
			var err error
			it.ExperimentRunID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "executionData":
			var err error
			it.ExecutionData, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNInfraIdentity2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "revisionID":
			var err error
			it.RevisionID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "completed":
			var err error
			it.Completed, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isRemoved":
			var err error
			it.IsRemoved, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy":
			var err error
			it.UpdatedBy, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRunSortInput(ctx context.Context, obj interface{}) (model.ExperimentRunSortInput, error) {
	var it model.ExperimentRunSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNExperimentSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "ascending":
			var err error
			it.Ascending, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentSortInput(ctx context.Context, obj interface{}) (model.ExperimentSortInput, error) {
	var it model.ExperimentSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNExperimentSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "ascending":
			var err error
			it.Ascending, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitConfig(ctx context.Context, obj interface{}) (model.GitConfig, error) {
	var it model.GitConfig
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "branch":
			var err error
			it.Branch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageRegistryInput(ctx context.Context, obj interface{}) (model.ImageRegistryInput, error) {
	var it model.ImageRegistryInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "isDefault":
			var err error
			it.IsDefault, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRegistryName":
			var err error
			it.ImageRegistryName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRepoName":
			var err error
			it.ImageRepoName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRegistryType":
			var err error
			it.ImageRegistryType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "secretName":
			var err error
			it.SecretName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "secretNamespace":
			var err error
			it.SecretNamespace, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "enableRegistry":
			var err error
			it.EnableRegistry, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInfraFilterInput(ctx context.Context, obj interface{}) (model.InfraFilterInput, error) {
	var it model.InfraFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName":
			var err error
			it.PlatformName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraScope":
			var err error
			it.InfraScope, err = ec.unmarshalOINFRA_SCOPE2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraScope(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInfraIdentity(ctx context.Context, obj interface{}) (model.InfraIdentity, error) {
	var it model.InfraIdentity
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessKey":
			var err error
			it.AccessKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version":
			var err error
			it.Version, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeGVRRequest(ctx context.Context, obj interface{}) (model.KubeGVRRequest, error) {
	var it model.KubeGVRRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "group":
			var err error
			it.Group, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version":
			var err error
			it.Version, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			it.Resource, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeObjectData(ctx context.Context, obj interface{}) (model.KubeObjectData, error) {
	var it model.KubeObjectData
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "requestID":
			var err error
			it.RequestID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNInfraIdentity2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "kubeObj":
			var err error
			it.KubeObj, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeObjectRequest(ctx context.Context, obj interface{}) (model.KubeObjectRequest, error) {
	var it model.KubeObjectRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kubeObjRequest":
			var err error
			it.KubeObjRequest, err = ec.unmarshalOKubeGVRRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeGVRRequest(ctx, v)
			if err != nil {
				return it, err
			}
		case "objectType":
			var err error
			it.ObjectType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workloads":
			var err error
			it.Workloads, err = ec.unmarshalOWorkload2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWorkload(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListChaosHubRequest(ctx context.Context, obj interface{}) (model.ListChaosHubRequest, error) {
	var it model.ListChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "chaosHubIDs":
			var err error
			it.ChaosHubIDs, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOChaosHubFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListEnvironmentRequest(ctx context.Context, obj interface{}) (model.ListEnvironmentRequest, error) {
	var it model.ListEnvironmentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "environmentIDs":
			var err error
			it.EnvironmentIDs, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOEnvironmentFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOEnvironmentSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListExperimentRequest(ctx context.Context, obj interface{}) (model.ListExperimentRequest, error) {
	var it model.ListExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentIDs":
			var err error
			it.ExperimentIDs, err = ec.unmarshalOID2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOExperimentSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOExperimentFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListExperimentRunRequest(ctx context.Context, obj interface{}) (model.ListExperimentRunRequest, error) {
	var it model.ListExperimentRunRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentRunIDs":
			var err error
			it.ExperimentRunIDs, err = ec.unmarshalOID2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentIDs":
			var err error
			it.ExperimentIDs, err = ec.unmarshalOID2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOExperimentRunSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOExperimentRunFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListInfraRequest(ctx context.Context, obj interface{}) (model.ListInfraRequest, error) {
	var it model.ListInfraRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraIDs":
			var err error
			it.InfraIDs, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "environmentIDs":
			var err error
			it.EnvironmentIDs, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOInfraFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewInfraEventRequest(ctx context.Context, obj interface{}) (model.NewInfraEventRequest, error) {
	var it model.NewInfraEventRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eventName":
			var err error
			it.EventName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessKey":
			var err error
			it.AccessKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPagination(ctx context.Context, obj interface{}) (model.Pagination, error) {
	var it model.Pagination
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "page":
			var err error
			it.Page, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error
			it.Limit, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLog(ctx context.Context, obj interface{}) (model.PodLog, error) {
	var it model.PodLog
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNInfraIdentity2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "requestID":
			var err error
			it.RequestID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunID":
			var err error
			it.ExperimentRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podName":
			var err error
			it.PodName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podType":
			var err error
			it.PodType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "log":
			var err error
			it.Log, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLogRequest(ctx context.Context, obj interface{}) (model.PodLogRequest, error) {
	var it model.PodLogRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentRunID":
			var err error
			it.ExperimentRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podName":
			var err error
			it.PodName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podNamespace":
			var err error
			it.PodNamespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podType":
			var err error
			it.PodType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expPod":
			var err error
			it.ExpPod, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "runnerPod":
			var err error
			it.RunnerPod, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosNamespace":
			var err error
			it.ChaosNamespace, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegisterInfraRequest(ctx context.Context, obj interface{}) (model.RegisterInfraRequest, error) {
	var it model.RegisterInfraRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "environmentID":
			var err error
			it.EnvironmentID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infrastructureType":
			var err error
			it.InfrastructureType, err = ec.unmarshalNInfrastructureType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName":
			var err error
			it.PlatformName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraNamespace":
			var err error
			it.InfraNamespace, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serviceAccount":
			var err error
			it.ServiceAccount, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraScope":
			var err error
			it.InfraScope, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraNsExists":
			var err error
			it.InfraNsExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraSaExists":
			var err error
			it.InfraSaExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipSsl":
			var err error
			it.SkipSsl, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nodeSelector":
			var err error
			it.NodeSelector, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tolerations":
			var err error
			it.Tolerations, err = ec.unmarshalOToleration2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐToleration(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveChaosExperimentRequest(ctx context.Context, obj interface{}) (model.SaveChaosExperimentRequest, error) {
	var it model.SaveChaosExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOExperimentType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentType(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manifest":
			var err error
			it.Manifest, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "infraID":
			var err error
			it.InfraID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputToleration(ctx context.Context, obj interface{}) (model.Toleration, error) {
	var it model.Toleration
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tolerationSeconds":
			var err error
			it.TolerationSeconds, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "key":
			var err error
			it.Key, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "operator":
			var err error
			it.Operator, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "effect":
			var err error
			it.Effect, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateChaosHubRequest(ctx context.Context, obj interface{}) (model.UpdateChaosHubRequest, error) {
	var it model.UpdateChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPublicKey":
			var err error
			it.SSHPublicKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEnvironmentRequest(ctx context.Context, obj interface{}) (model.UpdateEnvironmentRequest, error) {
	var it model.UpdateEnvironmentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "environmentID":
			var err error
			it.EnvironmentID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOEnvironmentType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWeightagesInput(ctx context.Context, obj interface{}) (model.WeightagesInput, error) {
	var it model.WeightagesInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "faultName":
			var err error
			it.FaultName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightage":
			var err error
			it.Weightage, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkload(ctx context.Context, obj interface{}) (model.Workload, error) {
	var it model.Workload
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kind":
			var err error
			it.Kind, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Audit(ctx context.Context, sel ast.SelectionSet, obj model.Audit) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ExperimentRun:
		return ec._ExperimentRun(ctx, sel, &obj)
	case *model.ExperimentRun:
		if obj == nil {
			return graphql.Null
		}
		return ec._ExperimentRun(ctx, sel, obj)
	case model.RecentExperimentRun:
		return ec._RecentExperimentRun(ctx, sel, &obj)
	case *model.RecentExperimentRun:
		if obj == nil {
			return graphql.Null
		}
		return ec._RecentExperimentRun(ctx, sel, obj)
	case model.Experiment:
		return ec._Experiment(ctx, sel, &obj)
	case *model.Experiment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Experiment(ctx, sel, obj)
	case model.Infra:
		return ec._Infra(ctx, sel, &obj)
	case *model.Infra:
		if obj == nil {
			return graphql.Null
		}
		return ec._Infra(ctx, sel, obj)
	case model.ChaosHub:
		return ec._ChaosHub(ctx, sel, &obj)
	case *model.ChaosHub:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChaosHub(ctx, sel, obj)
	case model.ChaosHubStatus:
		return ec._ChaosHubStatus(ctx, sel, &obj)
	case *model.ChaosHubStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChaosHubStatus(ctx, sel, obj)
	case model.Environment:
		return ec._Environment(ctx, sel, &obj)
	case *model.Environment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Environment(ctx, sel, obj)
	case model.ImageRegistryResponse:
		return ec._ImageRegistryResponse(ctx, sel, &obj)
	case *model.ImageRegistryResponse:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageRegistryResponse(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ResourceDetails(ctx context.Context, sel ast.SelectionSet, obj model.ResourceDetails) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Experiment:
		return ec._Experiment(ctx, sel, &obj)
	case *model.Experiment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Experiment(ctx, sel, obj)
	case model.Infra:
		return ec._Infra(ctx, sel, &obj)
	case *model.Infra:
		if obj == nil {
			return graphql.Null
		}
		return ec._Infra(ctx, sel, obj)
	case model.ChaosHub:
		return ec._ChaosHub(ctx, sel, &obj)
	case *model.ChaosHub:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChaosHub(ctx, sel, obj)
	case model.ChaosHubStatus:
		return ec._ChaosHubStatus(ctx, sel, &obj)
	case *model.ChaosHubStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChaosHubStatus(ctx, sel, obj)
	case model.Environment:
		return ec._Environment(ctx, sel, &obj)
	case *model.Environment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Environment(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var actionPayloadImplementors = []string{"ActionPayload"}

func (ec *executionContext) _ActionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ActionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActionPayload")
		case "requestID":
			out.Values[i] = ec._ActionPayload_requestID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requestType":
			out.Values[i] = ec._ActionPayload_requestType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "k8sManifest":
			out.Values[i] = ec._ActionPayload_k8sManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "namespace":
			out.Values[i] = ec._ActionPayload_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "externalData":
			out.Values[i] = ec._ActionPayload_externalData(ctx, field, obj)
		case "username":
			out.Values[i] = ec._ActionPayload_username(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var annotationImplementors = []string{"Annotation"}

func (ec *executionContext) _Annotation(ctx context.Context, sel ast.SelectionSet, obj *model.Annotation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Annotation")
		case "categories":
			out.Values[i] = ec._Annotation_categories(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "vendor":
			out.Values[i] = ec._Annotation_vendor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Annotation_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repository":
			out.Values[i] = ec._Annotation_repository(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "support":
			out.Values[i] = ec._Annotation_support(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chartDescription":
			out.Values[i] = ec._Annotation_chartDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosExperimentResponseImplementors = []string{"ChaosExperimentResponse"}

func (ec *executionContext) _ChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosExperimentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosExperimentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosExperimentResponse")
		case "experimentID":
			out.Values[i] = ec._ChaosExperimentResponse_experimentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ChaosExperimentResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cronSyntax":
			out.Values[i] = ec._ChaosExperimentResponse_cronSyntax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentName":
			out.Values[i] = ec._ChaosExperimentResponse_experimentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentDescription":
			out.Values[i] = ec._ChaosExperimentResponse_experimentDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomExperiment":
			out.Values[i] = ec._ChaosExperimentResponse_isCustomExperiment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tags":
			out.Values[i] = ec._ChaosExperimentResponse_tags(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosHubImplementors = []string{"ChaosHub", "ResourceDetails", "Audit"}

func (ec *executionContext) _ChaosHub(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosHub) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosHubImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosHub")
		case "id":
			out.Values[i] = ec._ChaosHub_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoURL":
			out.Values[i] = ec._ChaosHub_repoURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoBranch":
			out.Values[i] = ec._ChaosHub_repoBranch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ChaosHub_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDefault":
			out.Values[i] = ec._ChaosHub_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._ChaosHub_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tags":
			out.Values[i] = ec._ChaosHub_tags(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ChaosHub_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._ChaosHub_updatedBy(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ChaosHub_description(ctx, field, obj)
		case "hubType":
			out.Values[i] = ec._ChaosHub_hubType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPrivate":
			out.Values[i] = ec._ChaosHub_isPrivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authType":
			out.Values[i] = ec._ChaosHub_authType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token":
			out.Values[i] = ec._ChaosHub_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._ChaosHub_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._ChaosHub_password(ctx, field, obj)
		case "sshPrivateKey":
			out.Values[i] = ec._ChaosHub_sshPrivateKey(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ChaosHub_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ChaosHub_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ChaosHub_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastSyncedAt":
			out.Values[i] = ec._ChaosHub_lastSyncedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosHubStatusImplementors = []string{"ChaosHubStatus", "ResourceDetails", "Audit"}

func (ec *executionContext) _ChaosHubStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosHubStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosHubStatusImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosHubStatus")
		case "id":
			out.Values[i] = ec._ChaosHubStatus_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoURL":
			out.Values[i] = ec._ChaosHubStatus_repoURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoBranch":
			out.Values[i] = ec._ChaosHubStatus_repoBranch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isAvailable":
			out.Values[i] = ec._ChaosHubStatus_isAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalFaults":
			out.Values[i] = ec._ChaosHubStatus_totalFaults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalExperiments":
			out.Values[i] = ec._ChaosHubStatus_totalExperiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._ChaosHubStatus_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubType":
			out.Values[i] = ec._ChaosHubStatus_hubType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPrivate":
			out.Values[i] = ec._ChaosHubStatus_isPrivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authType":
			out.Values[i] = ec._ChaosHubStatus_authType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token":
			out.Values[i] = ec._ChaosHubStatus_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._ChaosHubStatus_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._ChaosHubStatus_password(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ChaosHubStatus_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sshPrivateKey":
			out.Values[i] = ec._ChaosHubStatus_sshPrivateKey(ctx, field, obj)
		case "sshPublicKey":
			out.Values[i] = ec._ChaosHubStatus_sshPublicKey(ctx, field, obj)
		case "lastSyncedAt":
			out.Values[i] = ec._ChaosHubStatus_lastSyncedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tags":
			out.Values[i] = ec._ChaosHubStatus_tags(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ChaosHubStatus_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._ChaosHubStatus_updatedBy(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ChaosHubStatus_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ChaosHubStatus_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._ChaosHubStatus_description(ctx, field, obj)
		case "isDefault":
			out.Values[i] = ec._ChaosHubStatus_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chartImplementors = []string{"Chart"}

func (ec *executionContext) _Chart(ctx context.Context, sel ast.SelectionSet, obj *model.Chart) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chartImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Chart")
		case "apiVersion":
			out.Values[i] = ec._Chart_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kind":
			out.Values[i] = ec._Chart_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._Chart_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._Chart_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "packageInfo":
			out.Values[i] = ec._Chart_packageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var confirmInfraRegistrationResponseImplementors = []string{"ConfirmInfraRegistrationResponse"}

func (ec *executionContext) _ConfirmInfraRegistrationResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ConfirmInfraRegistrationResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, confirmInfraRegistrationResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfirmInfraRegistrationResponse")
		case "isInfraConfirmed":
			out.Values[i] = ec._ConfirmInfraRegistrationResponse_isInfraConfirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newAccessKey":
			out.Values[i] = ec._ConfirmInfraRegistrationResponse_newAccessKey(ctx, field, obj)
		case "infraID":
			out.Values[i] = ec._ConfirmInfraRegistrationResponse_infraID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var environmentImplementors = []string{"Environment", "ResourceDetails", "Audit"}

func (ec *executionContext) _Environment(ctx context.Context, sel ast.SelectionSet, obj *model.Environment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, environmentImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Environment")
		case "projectID":
			out.Values[i] = ec._Environment_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "environmentID":
			out.Values[i] = ec._Environment_environmentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Environment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Environment_description(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Environment_tags(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Environment_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Environment_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdBy":
			out.Values[i] = ec._Environment_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Environment_updatedBy(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Environment_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._Environment_isRemoved(ctx, field, obj)
		case "infraIDs":
			out.Values[i] = ec._Environment_infraIDs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentImplementors = []string{"Experiment", "ResourceDetails", "Audit"}

func (ec *executionContext) _Experiment(ctx context.Context, sel ast.SelectionSet, obj *model.Experiment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Experiment")
		case "projectID":
			out.Values[i] = ec._Experiment_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentID":
			out.Values[i] = ec._Experiment_experimentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentType":
			out.Values[i] = ec._Experiment_experimentType(ctx, field, obj)
		case "experimentManifest":
			out.Values[i] = ec._Experiment_experimentManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cronSyntax":
			out.Values[i] = ec._Experiment_cronSyntax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Experiment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Experiment_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightages":
			out.Values[i] = ec._Experiment_weightages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomExperiment":
			out.Values[i] = ec._Experiment_isCustomExperiment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Experiment_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Experiment_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infra":
			out.Values[i] = ec._Experiment_infra(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._Experiment_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tags":
			out.Values[i] = ec._Experiment_tags(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._Experiment_createdBy(ctx, field, obj)
		case "recentExperimentRunDetails":
			out.Values[i] = ec._Experiment_recentExperimentRunDetails(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Experiment_updatedBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentDetailsImplementors = []string{"ExperimentDetails"}

func (ec *executionContext) _ExperimentDetails(ctx context.Context, sel ast.SelectionSet, obj *model.ExperimentDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExperimentDetails")
		case "engineDetails":
			out.Values[i] = ec._ExperimentDetails_engineDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentDetails":
			out.Values[i] = ec._ExperimentDetails_experimentDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentRunImplementors = []string{"ExperimentRun", "Audit"}

func (ec *executionContext) _ExperimentRun(ctx context.Context, sel ast.SelectionSet, obj *model.ExperimentRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentRunImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExperimentRun")
		case "projectID":
			out.Values[i] = ec._ExperimentRun_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentRunID":
			out.Values[i] = ec._ExperimentRun_experimentRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentType":
			out.Values[i] = ec._ExperimentRun_experimentType(ctx, field, obj)
		case "experimentID":
			out.Values[i] = ec._ExperimentRun_experimentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightages":
			out.Values[i] = ec._ExperimentRun_weightages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ExperimentRun_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ExperimentRun_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infra":
			out.Values[i] = ec._ExperimentRun_infra(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentName":
			out.Values[i] = ec._ExperimentRun_experimentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentManifest":
			out.Values[i] = ec._ExperimentRun_experimentManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "phase":
			out.Values[i] = ec._ExperimentRun_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resiliencyScore":
			out.Values[i] = ec._ExperimentRun_resiliencyScore(ctx, field, obj)
		case "faultsPassed":
			out.Values[i] = ec._ExperimentRun_faultsPassed(ctx, field, obj)
		case "faultsFailed":
			out.Values[i] = ec._ExperimentRun_faultsFailed(ctx, field, obj)
		case "faultsAwaited":
			out.Values[i] = ec._ExperimentRun_faultsAwaited(ctx, field, obj)
		case "faultsStopped":
			out.Values[i] = ec._ExperimentRun_faultsStopped(ctx, field, obj)
		case "faultsNa":
			out.Values[i] = ec._ExperimentRun_faultsNa(ctx, field, obj)
		case "totalFaults":
			out.Values[i] = ec._ExperimentRun_totalFaults(ctx, field, obj)
		case "executionData":
			out.Values[i] = ec._ExperimentRun_executionData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._ExperimentRun_isRemoved(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._ExperimentRun_updatedBy(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ExperimentRun_createdBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentsImplementors = []string{"Experiments"}

func (ec *executionContext) _Experiments(ctx context.Context, sel ast.SelectionSet, obj *model.Experiments) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Experiments")
		case "name":
			out.Values[i] = ec._Experiments_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CSV":
			out.Values[i] = ec._Experiments_CSV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "desc":
			out.Values[i] = ec._Experiments_desc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var faultDetailsImplementors = []string{"FaultDetails"}

func (ec *executionContext) _FaultDetails(ctx context.Context, sel ast.SelectionSet, obj *model.FaultDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, faultDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FaultDetails")
		case "fault":
			out.Values[i] = ec._FaultDetails_fault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "engine":
			out.Values[i] = ec._FaultDetails_engine(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "csv":
			out.Values[i] = ec._FaultDetails_csv(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var faultListImplementors = []string{"FaultList"}

func (ec *executionContext) _FaultList(ctx context.Context, sel ast.SelectionSet, obj *model.FaultList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, faultListImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FaultList")
		case "name":
			out.Values[i] = ec._FaultList_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "displayName":
			out.Values[i] = ec._FaultList_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._FaultList_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "plan":
			out.Values[i] = ec._FaultList_plan(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getChaosHubStatsResponseImplementors = []string{"GetChaosHubStatsResponse"}

func (ec *executionContext) _GetChaosHubStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetChaosHubStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getChaosHubStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetChaosHubStatsResponse")
		case "totalChaosHubs":
			out.Values[i] = ec._GetChaosHubStatsResponse_totalChaosHubs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getExperimentResponseImplementors = []string{"GetExperimentResponse"}

func (ec *executionContext) _GetExperimentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetExperimentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getExperimentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetExperimentResponse")
		case "experimentDetails":
			out.Values[i] = ec._GetExperimentResponse_experimentDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "averageResiliencyScore":
			out.Values[i] = ec._GetExperimentResponse_averageResiliencyScore(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getExperimentRunStatsResponseImplementors = []string{"GetExperimentRunStatsResponse"}

func (ec *executionContext) _GetExperimentRunStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetExperimentRunStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getExperimentRunStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetExperimentRunStatsResponse")
		case "totalExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCompletedExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalCompletedExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalTerminatedExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalTerminatedExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalRunningExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalRunningExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalStoppedExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalStoppedExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalErroredExperimentRuns":
			out.Values[i] = ec._GetExperimentRunStatsResponse_totalErroredExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getExperimentStatsResponseImplementors = []string{"GetExperimentStatsResponse"}

func (ec *executionContext) _GetExperimentStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetExperimentStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getExperimentStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetExperimentStatsResponse")
		case "totalExperiments":
			out.Values[i] = ec._GetExperimentStatsResponse_totalExperiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalExpCategorizedByResiliencyScore":
			out.Values[i] = ec._GetExperimentStatsResponse_totalExpCategorizedByResiliencyScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getInfraStatsResponseImplementors = []string{"GetInfraStatsResponse"}

func (ec *executionContext) _GetInfraStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GetInfraStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getInfraStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetInfraStatsResponse")
		case "totalInfrastructures":
			out.Values[i] = ec._GetInfraStatsResponse_totalInfrastructures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalActiveInfrastructure":
			out.Values[i] = ec._GetInfraStatsResponse_totalActiveInfrastructure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalInactiveInfrastructures":
			out.Values[i] = ec._GetInfraStatsResponse_totalInactiveInfrastructures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalConfirmedInfrastructure":
			out.Values[i] = ec._GetInfraStatsResponse_totalConfirmedInfrastructure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalNonConfirmedInfrastructures":
			out.Values[i] = ec._GetInfraStatsResponse_totalNonConfirmedInfrastructures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitConfigResponseImplementors = []string{"GitConfigResponse"}

func (ec *executionContext) _GitConfigResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GitConfigResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitConfigResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitConfigResponse")
		case "enabled":
			out.Values[i] = ec._GitConfigResponse_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._GitConfigResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "branch":
			out.Values[i] = ec._GitConfigResponse_branch(ctx, field, obj)
		case "repoURL":
			out.Values[i] = ec._GitConfigResponse_repoURL(ctx, field, obj)
		case "authType":
			out.Values[i] = ec._GitConfigResponse_authType(ctx, field, obj)
		case "token":
			out.Values[i] = ec._GitConfigResponse_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._GitConfigResponse_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._GitConfigResponse_password(ctx, field, obj)
		case "sshPrivateKey":
			out.Values[i] = ec._GitConfigResponse_sshPrivateKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var imageRegistryImplementors = []string{"ImageRegistry"}

func (ec *executionContext) _ImageRegistry(ctx context.Context, sel ast.SelectionSet, obj *model.ImageRegistry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageRegistryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageRegistry")
		case "isDefault":
			out.Values[i] = ec._ImageRegistry_isDefault(ctx, field, obj)
		case "imageRegistryName":
			out.Values[i] = ec._ImageRegistry_imageRegistryName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRepoName":
			out.Values[i] = ec._ImageRegistry_imageRepoName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRegistryType":
			out.Values[i] = ec._ImageRegistry_imageRegistryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "secretName":
			out.Values[i] = ec._ImageRegistry_secretName(ctx, field, obj)
		case "secretNamespace":
			out.Values[i] = ec._ImageRegistry_secretNamespace(ctx, field, obj)
		case "enableRegistry":
			out.Values[i] = ec._ImageRegistry_enableRegistry(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var imageRegistryResponseImplementors = []string{"ImageRegistryResponse", "Audit"}

func (ec *executionContext) _ImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ImageRegistryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageRegistryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageRegistryResponse")
		case "isDefault":
			out.Values[i] = ec._ImageRegistryResponse_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRegistryInfo":
			out.Values[i] = ec._ImageRegistryResponse_imageRegistryInfo(ctx, field, obj)
		case "imageRegistryID":
			out.Values[i] = ec._ImageRegistryResponse_imageRegistryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ImageRegistryResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ImageRegistryResponse_updatedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ImageRegistryResponse_createdAt(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ImageRegistryResponse_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._ImageRegistryResponse_updatedBy(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ImageRegistryResponse_isRemoved(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var infraImplementors = []string{"Infra", "ResourceDetails", "Audit"}

func (ec *executionContext) _Infra(ctx context.Context, sel ast.SelectionSet, obj *model.Infra) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, infraImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Infra")
		case "projectID":
			out.Values[i] = ec._Infra_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infraID":
			out.Values[i] = ec._Infra_infraID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Infra_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Infra_description(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Infra_tags(ctx, field, obj)
		case "environmentID":
			out.Values[i] = ec._Infra_environmentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "platformName":
			out.Values[i] = ec._Infra_platformName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isActive":
			out.Values[i] = ec._Infra_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isInfraConfirmed":
			out.Values[i] = ec._Infra_isInfraConfirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._Infra_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Infra_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Infra_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "noOfExperiments":
			out.Values[i] = ec._Infra_noOfExperiments(ctx, field, obj)
		case "noOfExperimentRuns":
			out.Values[i] = ec._Infra_noOfExperimentRuns(ctx, field, obj)
		case "token":
			out.Values[i] = ec._Infra_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infraNamespace":
			out.Values[i] = ec._Infra_infraNamespace(ctx, field, obj)
		case "serviceAccount":
			out.Values[i] = ec._Infra_serviceAccount(ctx, field, obj)
		case "infraScope":
			out.Values[i] = ec._Infra_infraScope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infraNsExists":
			out.Values[i] = ec._Infra_infraNsExists(ctx, field, obj)
		case "infraSaExists":
			out.Values[i] = ec._Infra_infraSaExists(ctx, field, obj)
		case "lastExperimentTimestamp":
			out.Values[i] = ec._Infra_lastExperimentTimestamp(ctx, field, obj)
		case "startTime":
			out.Values[i] = ec._Infra_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":
			out.Values[i] = ec._Infra_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdBy":
			out.Values[i] = ec._Infra_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Infra_updatedBy(ctx, field, obj)
		case "infraType":
			out.Values[i] = ec._Infra_infraType(ctx, field, obj)
		case "updateStatus":
			out.Values[i] = ec._Infra_updateStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var infraActionResponseImplementors = []string{"InfraActionResponse"}

func (ec *executionContext) _InfraActionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.InfraActionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, infraActionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InfraActionResponse")
		case "projectID":
			out.Values[i] = ec._InfraActionResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "action":
			out.Values[i] = ec._InfraActionResponse_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var infraEventResponseImplementors = []string{"InfraEventResponse"}

func (ec *executionContext) _InfraEventResponse(ctx context.Context, sel ast.SelectionSet, obj *model.InfraEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, infraEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InfraEventResponse")
		case "eventID":
			out.Values[i] = ec._InfraEventResponse_eventID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventType":
			out.Values[i] = ec._InfraEventResponse_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventName":
			out.Values[i] = ec._InfraEventResponse_eventName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._InfraEventResponse_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infra":
			out.Values[i] = ec._InfraEventResponse_infra(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var infraVersionDetailsImplementors = []string{"InfraVersionDetails"}

func (ec *executionContext) _InfraVersionDetails(ctx context.Context, sel ast.SelectionSet, obj *model.InfraVersionDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, infraVersionDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InfraVersionDetails")
		case "latestVersion":
			out.Values[i] = ec._InfraVersionDetails_latestVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "compatibleVersions":
			out.Values[i] = ec._InfraVersionDetails_compatibleVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kubeObjectImplementors = []string{"KubeObject"}

func (ec *executionContext) _KubeObject(ctx context.Context, sel ast.SelectionSet, obj *model.KubeObject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kubeObjectImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeObject")
		case "namespace":
			out.Values[i] = ec._KubeObject_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "data":
			out.Values[i] = ec._KubeObject_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kubeObjectResponseImplementors = []string{"KubeObjectResponse"}

func (ec *executionContext) _KubeObjectResponse(ctx context.Context, sel ast.SelectionSet, obj *model.KubeObjectResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kubeObjectResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeObjectResponse")
		case "infraID":
			out.Values[i] = ec._KubeObjectResponse_infraID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kubeObj":
			out.Values[i] = ec._KubeObjectResponse_kubeObj(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var linkImplementors = []string{"Link"}

func (ec *executionContext) _Link(ctx context.Context, sel ast.SelectionSet, obj *model.Link) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, linkImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Link")
		case "name":
			out.Values[i] = ec._Link_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":
			out.Values[i] = ec._Link_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listEnvironmentResponseImplementors = []string{"ListEnvironmentResponse"}

func (ec *executionContext) _ListEnvironmentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListEnvironmentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listEnvironmentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListEnvironmentResponse")
		case "totalNoOfEnvironments":
			out.Values[i] = ec._ListEnvironmentResponse_totalNoOfEnvironments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "environments":
			out.Values[i] = ec._ListEnvironmentResponse_environments(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listExperimentResponseImplementors = []string{"ListExperimentResponse"}

func (ec *executionContext) _ListExperimentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListExperimentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listExperimentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListExperimentResponse")
		case "totalNoOfExperiments":
			out.Values[i] = ec._ListExperimentResponse_totalNoOfExperiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._ListExperimentResponse_experiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listExperimentRunResponseImplementors = []string{"ListExperimentRunResponse"}

func (ec *executionContext) _ListExperimentRunResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListExperimentRunResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listExperimentRunResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListExperimentRunResponse")
		case "totalNoOfExperimentRuns":
			out.Values[i] = ec._ListExperimentRunResponse_totalNoOfExperimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentRuns":
			out.Values[i] = ec._ListExperimentRunResponse_experimentRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listInfraResponseImplementors = []string{"ListInfraResponse"}

func (ec *executionContext) _ListInfraResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListInfraResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listInfraResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListInfraResponse")
		case "totalNoOfInfras":
			out.Values[i] = ec._ListInfraResponse_totalNoOfInfras(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infras":
			out.Values[i] = ec._ListInfraResponse_infras(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maintainerImplementors = []string{"Maintainer"}

func (ec *executionContext) _Maintainer(ctx context.Context, sel ast.SelectionSet, obj *model.Maintainer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maintainerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Maintainer")
		case "name":
			out.Values[i] = ec._Maintainer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "email":
			out.Values[i] = ec._Maintainer_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metadataImplementors = []string{"Metadata"}

func (ec *executionContext) _Metadata(ctx context.Context, sel ast.SelectionSet, obj *model.Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "name":
			out.Values[i] = ec._Metadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":
			out.Values[i] = ec._Metadata_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "annotations":
			out.Values[i] = ec._Metadata_annotations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createChaosExperiment":
			out.Values[i] = ec._Mutation_createChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveChaosExperiment":
			out.Values[i] = ec._Mutation_saveChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "runChaosExperiment":
			out.Values[i] = ec._Mutation_runChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChaosExperiment":
			out.Values[i] = ec._Mutation_updateChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChaosExperiment":
			out.Values[i] = ec._Mutation_deleteChaosExperiment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosExperimentRun":
			out.Values[i] = ec._Mutation_chaosExperimentRun(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "registerInfra":
			out.Values[i] = ec._Mutation_registerInfra(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "confirmInfraRegistration":
			out.Values[i] = ec._Mutation_confirmInfraRegistration(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteInfra":
			out.Values[i] = ec._Mutation_deleteInfra(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "getManifestWithInfraID":
			out.Values[i] = ec._Mutation_getManifestWithInfraID(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podLog":
			out.Values[i] = ec._Mutation_podLog(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kubeObj":
			out.Values[i] = ec._Mutation_kubeObj(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addChaosHub":
			out.Values[i] = ec._Mutation_addChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addRemoteChaosHub":
			out.Values[i] = ec._Mutation_addRemoteChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveChaosHub":
			out.Values[i] = ec._Mutation_saveChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "syncChaosHub":
			out.Values[i] = ec._Mutation_syncChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "generateSSHKey":
			out.Values[i] = ec._Mutation_generateSSHKey(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChaosHub":
			out.Values[i] = ec._Mutation_updateChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChaosHub":
			out.Values[i] = ec._Mutation_deleteChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createEnvironment":
			out.Values[i] = ec._Mutation_createEnvironment(ctx, field)
		case "updateEnvironment":
			out.Values[i] = ec._Mutation_updateEnvironment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteEnvironment":
			out.Values[i] = ec._Mutation_deleteEnvironment(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gitopsNotifier":
			out.Values[i] = ec._Mutation_gitopsNotifier(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "enableGitOps":
			out.Values[i] = ec._Mutation_enableGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "disableGitOps":
			out.Values[i] = ec._Mutation_disableGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateGitOps":
			out.Values[i] = ec._Mutation_updateGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createImageRegistry":
			out.Values[i] = ec._Mutation_createImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateImageRegistry":
			out.Values[i] = ec._Mutation_updateImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteImageRegistry":
			out.Values[i] = ec._Mutation_deleteImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var objectDataImplementors = []string{"ObjectData"}

func (ec *executionContext) _ObjectData(ctx context.Context, sel ast.SelectionSet, obj *model.ObjectData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, objectDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObjectData")
		case "labels":
			out.Values[i] = ec._ObjectData_labels(ctx, field, obj)
		case "name":
			out.Values[i] = ec._ObjectData_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageInformationImplementors = []string{"PackageInformation"}

func (ec *executionContext) _PackageInformation(ctx context.Context, sel ast.SelectionSet, obj *model.PackageInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PackageInformation")
		case "packageName":
			out.Values[i] = ec._PackageInformation_packageName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._PackageInformation_experiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var podLogResponseImplementors = []string{"PodLogResponse"}

func (ec *executionContext) _PodLogResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PodLogResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podLogResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodLogResponse")
		case "experimentRunID":
			out.Values[i] = ec._PodLogResponse_experimentRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podName":
			out.Values[i] = ec._PodLogResponse_podName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podType":
			out.Values[i] = ec._PodLogResponse_podType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "log":
			out.Values[i] = ec._PodLogResponse_log(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var predefinedExperimentListImplementors = []string{"PredefinedExperimentList"}

func (ec *executionContext) _PredefinedExperimentList(ctx context.Context, sel ast.SelectionSet, obj *model.PredefinedExperimentList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, predefinedExperimentListImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PredefinedExperimentList")
		case "experimentName":
			out.Values[i] = ec._PredefinedExperimentList_experimentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentCSV":
			out.Values[i] = ec._PredefinedExperimentList_experimentCSV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentManifest":
			out.Values[i] = ec._PredefinedExperimentList_experimentManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var providerImplementors = []string{"Provider"}

func (ec *executionContext) _Provider(ctx context.Context, sel ast.SelectionSet, obj *model.Provider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Provider")
		case "name":
			out.Values[i] = ec._Provider_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getExperimentRun":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperimentRun(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listExperimentRun":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listExperimentRun(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getExperiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperiment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listExperiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listExperiment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getExperimentRunStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperimentRunStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getExperimentStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperimentStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getInfra":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInfra(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listInfras":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listInfras(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getInfraDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInfraDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getInfraManifest":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInfraManifest(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getInfraStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInfraStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getVersionDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getVersionDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getServerVersion":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getServerVersion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listChaosFaults":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listChaosFaults(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getChaosFault":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getChaosFault(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listChaosHub":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listChaosHub(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getChaosHub":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getChaosHub(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listPredefinedExperiments":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listPredefinedExperiments(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPredefinedExperiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPredefinedExperiment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getChaosHubStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getChaosHubStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getEnvironment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getEnvironment(ctx, field)
				return res
			})
		case "listEnvironments":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listEnvironments(ctx, field)
				return res
			})
		case "getGitOpsDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGitOpsDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listImageRegistry":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listImageRegistry(ctx, field)
				return res
			})
		case "getImageRegistry":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getImageRegistry(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var recentExperimentRunImplementors = []string{"RecentExperimentRun", "Audit"}

func (ec *executionContext) _RecentExperimentRun(ctx context.Context, sel ast.SelectionSet, obj *model.RecentExperimentRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recentExperimentRunImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RecentExperimentRun")
		case "experimentRunID":
			out.Values[i] = ec._RecentExperimentRun_experimentRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "phase":
			out.Values[i] = ec._RecentExperimentRun_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resiliencyScore":
			out.Values[i] = ec._RecentExperimentRun_resiliencyScore(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._RecentExperimentRun_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RecentExperimentRun_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdBy":
			out.Values[i] = ec._RecentExperimentRun_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._RecentExperimentRun_updatedBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var registerInfraResponseImplementors = []string{"RegisterInfraResponse"}

func (ec *executionContext) _RegisterInfraResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RegisterInfraResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registerInfraResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegisterInfraResponse")
		case "token":
			out.Values[i] = ec._RegisterInfraResponse_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "infraID":
			out.Values[i] = ec._RegisterInfraResponse_infraID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._RegisterInfraResponse_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manifest":
			out.Values[i] = ec._RegisterInfraResponse_manifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resilienceScoreCategoryImplementors = []string{"ResilienceScoreCategory"}

func (ec *executionContext) _ResilienceScoreCategory(ctx context.Context, sel ast.SelectionSet, obj *model.ResilienceScoreCategory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resilienceScoreCategoryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResilienceScoreCategory")
		case "id":
			out.Values[i] = ec._ResilienceScoreCategory_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._ResilienceScoreCategory_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runChaosExperimentResponseImplementors = []string{"RunChaosExperimentResponse"}

func (ec *executionContext) _RunChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RunChaosExperimentResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runChaosExperimentResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunChaosExperimentResponse")
		case "notifyID":
			out.Values[i] = ec._RunChaosExperimentResponse_notifyID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sSHKeyImplementors = []string{"SSHKey"}

func (ec *executionContext) _SSHKey(ctx context.Context, sel ast.SelectionSet, obj *model.SSHKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sSHKeyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SSHKey")
		case "publicKey":
			out.Values[i] = ec._SSHKey_publicKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "privateKey":
			out.Values[i] = ec._SSHKey_privateKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var serverVersionResponseImplementors = []string{"ServerVersionResponse"}

func (ec *executionContext) _ServerVersionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ServerVersionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverVersionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServerVersionResponse")
		case "key":
			out.Values[i] = ec._ServerVersionResponse_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._ServerVersionResponse_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var specImplementors = []string{"Spec"}

func (ec *executionContext) _Spec(ctx context.Context, sel ast.SelectionSet, obj *model.Spec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, specImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Spec")
		case "displayName":
			out.Values[i] = ec._Spec_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "categoryDescription":
			out.Values[i] = ec._Spec_categoryDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "keywords":
			out.Values[i] = ec._Spec_keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maturity":
			out.Values[i] = ec._Spec_maturity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._Spec_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "minKubeVersion":
			out.Values[i] = ec._Spec_minKubeVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "provider":
			out.Values[i] = ec._Spec_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "links":
			out.Values[i] = ec._Spec_links(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "faults":
			out.Values[i] = ec._Spec_faults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._Spec_experiments(ctx, field, obj)
		case "chaosExpCRDLink":
			out.Values[i] = ec._Spec_chaosExpCRDLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "platforms":
			out.Values[i] = ec._Spec_platforms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosType":
			out.Values[i] = ec._Spec_chaosType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stopExperimentRunsRequestImplementors = []string{"StopExperimentRunsRequest"}

func (ec *executionContext) _StopExperimentRunsRequest(ctx context.Context, sel ast.SelectionSet, obj *model.StopExperimentRunsRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopExperimentRunsRequestImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopExperimentRunsRequest")
		case "projectID":
			out.Values[i] = ec._StopExperimentRunsRequest_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentID":
			out.Values[i] = ec._StopExperimentRunsRequest_experimentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentRunID":
			out.Values[i] = ec._StopExperimentRunsRequest_experimentRunID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "getInfraEvents":
		return ec._Subscription_getInfraEvents(ctx, fields[0])
	case "infraConnect":
		return ec._Subscription_infraConnect(ctx, fields[0])
	case "getPodLog":
		return ec._Subscription_getPodLog(ctx, fields[0])
	case "getKubeObject":
		return ec._Subscription_getKubeObject(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var userDetailsImplementors = []string{"UserDetails"}

func (ec *executionContext) _UserDetails(ctx context.Context, sel ast.SelectionSet, obj *model.UserDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserDetails")
		case "userID":
			out.Values[i] = ec._UserDetails_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "username":
			out.Values[i] = ec._UserDetails_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "email":
			out.Values[i] = ec._UserDetails_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var weightagesImplementors = []string{"Weightages"}

func (ec *executionContext) _Weightages(ctx context.Context, sel ast.SelectionSet, obj *model.Weightages) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weightagesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Weightages")
		case "faultName":
			out.Values[i] = ec._Weightages_faultName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightage":
			out.Values[i] = ec._Weightages_weightage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNActionPayload2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐActionPayload(ctx context.Context, sel ast.SelectionSet, v model.ActionPayload) graphql.Marshaler {
	return ec._ActionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNActionPayload2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐActionPayload(ctx context.Context, sel ast.SelectionSet, v *model.ActionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ActionPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAnnotation2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAnnotation(ctx context.Context, sel ast.SelectionSet, v model.Annotation) graphql.Marshaler {
	return ec._Annotation(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnotation2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAnnotation(ctx context.Context, sel ast.SelectionSet, v *model.Annotation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Annotation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, v interface{}) (model.AuthType, error) {
	var res model.AuthType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, sel ast.SelectionSet, v model.AuthType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNChaosExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentRequest(ctx context.Context, v interface{}) (model.ChaosExperimentRequest, error) {
	return ec.unmarshalInputChaosExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNChaosExperimentResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, v model.ChaosExperimentResponse) graphql.Marshaler {
	return ec._ChaosExperimentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosExperimentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, v *model.ChaosExperimentResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosExperimentResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNChaosHub2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHub(ctx context.Context, sel ast.SelectionSet, v model.ChaosHub) graphql.Marshaler {
	return ec._ChaosHub(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHub(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHub) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosHub(ctx, sel, v)
}

func (ec *executionContext) marshalNChaosHubStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v model.ChaosHubStatus) graphql.Marshaler {
	return ec._ChaosHubStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosHubStatus2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v []*model.ChaosHubStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOChaosHubStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChaosHubStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHubStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosHubStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNChart2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChart(ctx context.Context, sel ast.SelectionSet, v model.Chart) graphql.Marshaler {
	return ec._Chart(ctx, sel, &v)
}

func (ec *executionContext) marshalNChart2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChartᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Chart) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChart2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChart(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChart2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChart(ctx context.Context, sel ast.SelectionSet, v *model.Chart) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Chart(ctx, sel, v)
}

func (ec *executionContext) marshalNConfirmInfraRegistrationResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐConfirmInfraRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v model.ConfirmInfraRegistrationResponse) graphql.Marshaler {
	return ec._ConfirmInfraRegistrationResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfirmInfraRegistrationResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐConfirmInfraRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v *model.ConfirmInfraRegistrationResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ConfirmInfraRegistrationResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐCreateChaosHubRequest(ctx context.Context, v interface{}) (model.CreateChaosHubRequest, error) {
	return ec.unmarshalInputCreateChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalNCreateRemoteChaosHub2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐCreateRemoteChaosHub(ctx context.Context, v interface{}) (model.CreateRemoteChaosHub, error) {
	return ec.unmarshalInputCreateRemoteChaosHub(ctx, v)
}

func (ec *executionContext) unmarshalNEnvironmentSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentSortingField(ctx context.Context, v interface{}) (model.EnvironmentSortingField, error) {
	var res model.EnvironmentSortingField
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNEnvironmentSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentSortingField(ctx context.Context, sel ast.SelectionSet, v model.EnvironmentSortingField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEnvironmentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx context.Context, v interface{}) (model.EnvironmentType, error) {
	var res model.EnvironmentType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNEnvironmentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx context.Context, sel ast.SelectionSet, v model.EnvironmentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNExperiment2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiment(ctx context.Context, sel ast.SelectionSet, v model.Experiment) graphql.Marshaler {
	return ec._Experiment(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperiment2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiment(ctx context.Context, sel ast.SelectionSet, v []*model.Experiment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOExperiment2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperiment2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiment(ctx context.Context, sel ast.SelectionSet, v *model.Experiment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Experiment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRequest(ctx context.Context, v interface{}) (model.ExperimentRequest, error) {
	return ec.unmarshalInputExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNExperimentRun2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v model.ExperimentRun) graphql.Marshaler {
	return ec._ExperimentRun(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperimentRun2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v []*model.ExperimentRun) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOExperimentRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperimentRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentRun) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ExperimentRun(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExperimentRunRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunRequest(ctx context.Context, v interface{}) (model.ExperimentRunRequest, error) {
	return ec.unmarshalInputExperimentRunRequest(ctx, v)
}

func (ec *executionContext) unmarshalNExperimentRunStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunStatus(ctx context.Context, v interface{}) (model.ExperimentRunStatus, error) {
	var res model.ExperimentRunStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNExperimentRunStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunStatus(ctx context.Context, sel ast.SelectionSet, v model.ExperimentRunStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNExperimentSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentSortingField(ctx context.Context, v interface{}) (model.ExperimentSortingField, error) {
	var res model.ExperimentSortingField
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNExperimentSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentSortingField(ctx context.Context, sel ast.SelectionSet, v model.ExperimentSortingField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNExperiments2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiments(ctx context.Context, sel ast.SelectionSet, v model.Experiments) graphql.Marshaler {
	return ec._Experiments(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperiments2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentsᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Experiments) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExperiments2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiments(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperiments2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiments(ctx context.Context, sel ast.SelectionSet, v *model.Experiments) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Experiments(ctx, sel, v)
}

func (ec *executionContext) marshalNFaultDetails2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐFaultDetails(ctx context.Context, sel ast.SelectionSet, v model.FaultDetails) graphql.Marshaler {
	return ec._FaultDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalNFaultDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐFaultDetails(ctx context.Context, sel ast.SelectionSet, v *model.FaultDetails) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._FaultDetails(ctx, sel, v)
}

func (ec *executionContext) marshalNFaultList2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐFaultList(ctx context.Context, sel ast.SelectionSet, v model.FaultList) graphql.Marshaler {
	return ec._FaultList(ctx, sel, &v)
}

func (ec *executionContext) marshalNFaultList2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐFaultListᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FaultList) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFaultList2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐFaultList(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNFaultList2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐFaultList(ctx context.Context, sel ast.SelectionSet, v *model.FaultList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._FaultList(ctx, sel, v)
}

func (ec *executionContext) marshalNGetChaosHubStatsResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetChaosHubStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.GetChaosHubStatsResponse) graphql.Marshaler {
	return ec._GetChaosHubStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetChaosHubStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetChaosHubStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetChaosHubStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetChaosHubStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetExperimentResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetExperimentResponse(ctx context.Context, sel ast.SelectionSet, v model.GetExperimentResponse) graphql.Marshaler {
	return ec._GetExperimentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetExperimentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetExperimentResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetExperimentResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetExperimentResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetExperimentRunStatsResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetExperimentRunStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.GetExperimentRunStatsResponse) graphql.Marshaler {
	return ec._GetExperimentRunStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetExperimentRunStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetExperimentRunStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetExperimentRunStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetExperimentRunStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetExperimentStatsResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetExperimentStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.GetExperimentStatsResponse) graphql.Marshaler {
	return ec._GetExperimentStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetExperimentStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetExperimentStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetExperimentStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetExperimentStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetInfraStatsResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetInfraStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.GetInfraStatsResponse) graphql.Marshaler {
	return ec._GetInfraStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetInfraStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGetInfraStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.GetInfraStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GetInfraStatsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGitConfig2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGitConfig(ctx context.Context, v interface{}) (model.GitConfig, error) {
	return ec.unmarshalInputGitConfig(ctx, v)
}

func (ec *executionContext) marshalNGitConfigResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGitConfigResponse(ctx context.Context, sel ast.SelectionSet, v model.GitConfigResponse) graphql.Marshaler {
	return ec._GitConfigResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitConfigResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐGitConfigResponse(ctx context.Context, sel ast.SelectionSet, v *model.GitConfigResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GitConfigResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHubType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐHubType(ctx context.Context, v interface{}) (model.HubType, error) {
	var res model.HubType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNHubType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐHubType(ctx context.Context, sel ast.SelectionSet, v model.HubType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNImageRegistryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryInput(ctx context.Context, v interface{}) (model.ImageRegistryInput, error) {
	return ec.unmarshalInputImageRegistryInput(ctx, v)
}

func (ec *executionContext) marshalNImageRegistryResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v model.ImageRegistryResponse) graphql.Marshaler {
	return ec._ImageRegistryResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v *model.ImageRegistryResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImageRegistryResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNInfra2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx context.Context, sel ast.SelectionSet, v model.Infra) graphql.Marshaler {
	return ec._Infra(ctx, sel, &v)
}

func (ec *executionContext) marshalNInfra2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx context.Context, sel ast.SelectionSet, v []*model.Infra) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInfra2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInfra2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx context.Context, sel ast.SelectionSet, v *model.Infra) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Infra(ctx, sel, v)
}

func (ec *executionContext) marshalNInfraActionResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraActionResponse(ctx context.Context, sel ast.SelectionSet, v model.InfraActionResponse) graphql.Marshaler {
	return ec._InfraActionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNInfraActionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraActionResponse(ctx context.Context, sel ast.SelectionSet, v *model.InfraActionResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InfraActionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNInfraEventResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraEventResponse(ctx context.Context, sel ast.SelectionSet, v model.InfraEventResponse) graphql.Marshaler {
	return ec._InfraEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNInfraEventResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraEventResponse(ctx context.Context, sel ast.SelectionSet, v *model.InfraEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InfraEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInfraIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraIdentity(ctx context.Context, v interface{}) (model.InfraIdentity, error) {
	return ec.unmarshalInputInfraIdentity(ctx, v)
}

func (ec *executionContext) unmarshalNInfraIdentity2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraIdentity(ctx context.Context, v interface{}) (*model.InfraIdentity, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNInfraIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraIdentity(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNInfraVersionDetails2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraVersionDetails(ctx context.Context, sel ast.SelectionSet, v model.InfraVersionDetails) graphql.Marshaler {
	return ec._InfraVersionDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalNInfraVersionDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraVersionDetails(ctx context.Context, sel ast.SelectionSet, v *model.InfraVersionDetails) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InfraVersionDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInfrastructureType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx context.Context, v interface{}) (model.InfrastructureType, error) {
	var res model.InfrastructureType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNInfrastructureType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx context.Context, sel ast.SelectionSet, v model.InfrastructureType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNKubeObject2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObject(ctx context.Context, sel ast.SelectionSet, v []*model.KubeObject) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOKubeObject2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObject(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNKubeObjectData2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObjectData(ctx context.Context, v interface{}) (model.KubeObjectData, error) {
	return ec.unmarshalInputKubeObjectData(ctx, v)
}

func (ec *executionContext) unmarshalNKubeObjectRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObjectRequest(ctx context.Context, v interface{}) (model.KubeObjectRequest, error) {
	return ec.unmarshalInputKubeObjectRequest(ctx, v)
}

func (ec *executionContext) marshalNKubeObjectResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObjectResponse(ctx context.Context, sel ast.SelectionSet, v model.KubeObjectResponse) graphql.Marshaler {
	return ec._KubeObjectResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNKubeObjectResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObjectResponse(ctx context.Context, sel ast.SelectionSet, v *model.KubeObjectResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._KubeObjectResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNLink2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐLink(ctx context.Context, sel ast.SelectionSet, v model.Link) graphql.Marshaler {
	return ec._Link(ctx, sel, &v)
}

func (ec *executionContext) marshalNLink2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐLinkᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Link) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLink2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNLink2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐLink(ctx context.Context, sel ast.SelectionSet, v *model.Link) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Link(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentRequest(ctx context.Context, v interface{}) (model.ListExperimentRequest, error) {
	return ec.unmarshalInputListExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNListExperimentResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentResponse(ctx context.Context, sel ast.SelectionSet, v model.ListExperimentResponse) graphql.Marshaler {
	return ec._ListExperimentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListExperimentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListExperimentResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListExperimentResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListExperimentRunRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentRunRequest(ctx context.Context, v interface{}) (model.ListExperimentRunRequest, error) {
	return ec.unmarshalInputListExperimentRunRequest(ctx, v)
}

func (ec *executionContext) marshalNListExperimentRunResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentRunResponse(ctx context.Context, sel ast.SelectionSet, v model.ListExperimentRunResponse) graphql.Marshaler {
	return ec._ListExperimentRunResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListExperimentRunResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListExperimentRunResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListExperimentRunResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListExperimentRunResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNListInfraResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListInfraResponse(ctx context.Context, sel ast.SelectionSet, v model.ListInfraResponse) graphql.Marshaler {
	return ec._ListInfraResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListInfraResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListInfraResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListInfraResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListInfraResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNMaintainer2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐMaintainer(ctx context.Context, sel ast.SelectionSet, v model.Maintainer) graphql.Marshaler {
	return ec._Maintainer(ctx, sel, &v)
}

func (ec *executionContext) marshalNMaintainer2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐMaintainerᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Maintainer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMaintainer2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐMaintainer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMaintainer2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐMaintainer(ctx context.Context, sel ast.SelectionSet, v *model.Maintainer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Maintainer(ctx, sel, v)
}

func (ec *executionContext) marshalNMetadata2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐMetadata(ctx context.Context, sel ast.SelectionSet, v model.Metadata) graphql.Marshaler {
	return ec._Metadata(ctx, sel, &v)
}

func (ec *executionContext) marshalNMetadata2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐMetadata(ctx context.Context, sel ast.SelectionSet, v *model.Metadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Metadata(ctx, sel, v)
}

func (ec *executionContext) marshalNObjectData2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐObjectData(ctx context.Context, sel ast.SelectionSet, v []*model.ObjectData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOObjectData2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐObjectData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPackageInformation2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPackageInformation(ctx context.Context, sel ast.SelectionSet, v model.PackageInformation) graphql.Marshaler {
	return ec._PackageInformation(ctx, sel, &v)
}

func (ec *executionContext) marshalNPackageInformation2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPackageInformation(ctx context.Context, sel ast.SelectionSet, v *model.PackageInformation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PackageInformation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPodLog2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPodLog(ctx context.Context, v interface{}) (model.PodLog, error) {
	return ec.unmarshalInputPodLog(ctx, v)
}

func (ec *executionContext) unmarshalNPodLogRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPodLogRequest(ctx context.Context, v interface{}) (model.PodLogRequest, error) {
	return ec.unmarshalInputPodLogRequest(ctx, v)
}

func (ec *executionContext) marshalNPodLogResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPodLogResponse(ctx context.Context, sel ast.SelectionSet, v model.PodLogResponse) graphql.Marshaler {
	return ec._PodLogResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPodLogResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPodLogResponse(ctx context.Context, sel ast.SelectionSet, v *model.PodLogResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PodLogResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPredefinedExperimentList2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPredefinedExperimentList(ctx context.Context, sel ast.SelectionSet, v model.PredefinedExperimentList) graphql.Marshaler {
	return ec._PredefinedExperimentList(ctx, sel, &v)
}

func (ec *executionContext) marshalNPredefinedExperimentList2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPredefinedExperimentListᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.PredefinedExperimentList) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPredefinedExperimentList2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPredefinedExperimentList(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPredefinedExperimentList2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPredefinedExperimentList(ctx context.Context, sel ast.SelectionSet, v *model.PredefinedExperimentList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PredefinedExperimentList(ctx, sel, v)
}

func (ec *executionContext) marshalNProvider2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐProvider(ctx context.Context, sel ast.SelectionSet, v model.Provider) graphql.Marshaler {
	return ec._Provider(ctx, sel, &v)
}

func (ec *executionContext) marshalNProvider2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐProvider(ctx context.Context, sel ast.SelectionSet, v *model.Provider) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Provider(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRegisterInfraRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRegisterInfraRequest(ctx context.Context, v interface{}) (model.RegisterInfraRequest, error) {
	return ec.unmarshalInputRegisterInfraRequest(ctx, v)
}

func (ec *executionContext) marshalNRegisterInfraResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRegisterInfraResponse(ctx context.Context, sel ast.SelectionSet, v model.RegisterInfraResponse) graphql.Marshaler {
	return ec._RegisterInfraResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRegisterInfraResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRegisterInfraResponse(ctx context.Context, sel ast.SelectionSet, v *model.RegisterInfraResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RegisterInfraResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNResilienceScoreCategory2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐResilienceScoreCategory(ctx context.Context, sel ast.SelectionSet, v []*model.ResilienceScoreCategory) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOResilienceScoreCategory2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐResilienceScoreCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRunChaosExperimentResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRunChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, v model.RunChaosExperimentResponse) graphql.Marshaler {
	return ec._RunChaosExperimentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRunChaosExperimentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRunChaosExperimentResponse(ctx context.Context, sel ast.SelectionSet, v *model.RunChaosExperimentResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RunChaosExperimentResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSSHKey2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐSSHKey(ctx context.Context, sel ast.SelectionSet, v model.SSHKey) graphql.Marshaler {
	return ec._SSHKey(ctx, sel, &v)
}

func (ec *executionContext) marshalNSSHKey2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐSSHKey(ctx context.Context, sel ast.SelectionSet, v *model.SSHKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._SSHKey(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSaveChaosExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐSaveChaosExperimentRequest(ctx context.Context, v interface{}) (model.SaveChaosExperimentRequest, error) {
	return ec.unmarshalInputSaveChaosExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNServerVersionResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐServerVersionResponse(ctx context.Context, sel ast.SelectionSet, v model.ServerVersionResponse) graphql.Marshaler {
	return ec._ServerVersionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNServerVersionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐServerVersionResponse(ctx context.Context, sel ast.SelectionSet, v *model.ServerVersionResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ServerVersionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSpec2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐSpec(ctx context.Context, sel ast.SelectionSet, v model.Spec) graphql.Marshaler {
	return ec._Spec(ctx, sel, &v)
}

func (ec *executionContext) marshalNSpec2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐSpec(ctx context.Context, sel ast.SelectionSet, v *model.Spec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Spec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNUpdateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUpdateChaosHubRequest(ctx context.Context, v interface{}) (model.UpdateChaosHubRequest, error) {
	return ec.unmarshalInputUpdateChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUpdateStatus(ctx context.Context, v interface{}) (model.UpdateStatus, error) {
	var res model.UpdateStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNUpdateStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUpdateStatus(ctx context.Context, sel ast.SelectionSet, v model.UpdateStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWeightages2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightages(ctx context.Context, sel ast.SelectionSet, v model.Weightages) graphql.Marshaler {
	return ec._Weightages(ctx, sel, &v)
}

func (ec *executionContext) marshalNWeightages2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightagesᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Weightages) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeightages2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightages(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWeightages2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightages(ctx context.Context, sel ast.SelectionSet, v *model.Weightages) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Weightages(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWeightagesInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightagesInput(ctx context.Context, v interface{}) (model.WeightagesInput, error) {
	return ec.unmarshalInputWeightagesInput(ctx, v)
}

func (ec *executionContext) unmarshalNWeightagesInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightagesInputᚄ(ctx context.Context, v interface{}) ([]*model.WeightagesInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.WeightagesInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNWeightagesInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightagesInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNWeightagesInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightagesInput(ctx context.Context, v interface{}) (*model.WeightagesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNWeightagesInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWeightagesInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, v interface{}) (model.AuthType, error) {
	var res model.AuthType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, sel ast.SelectionSet, v model.AuthType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAuthType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, v interface{}) (*model.AuthType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAuthType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, sel ast.SelectionSet, v *model.AuthType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOChaosExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentRequest(ctx context.Context, v interface{}) (model.ChaosExperimentRequest, error) {
	return ec.unmarshalInputChaosExperimentRequest(ctx, v)
}

func (ec *executionContext) unmarshalOChaosExperimentRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentRequest(ctx context.Context, v interface{}) (*model.ChaosExperimentRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChaosExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosExperimentRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOChaosHubFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubFilterInput(ctx context.Context, v interface{}) (model.ChaosHubFilterInput, error) {
	return ec.unmarshalInputChaosHubFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOChaosHubFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubFilterInput(ctx context.Context, v interface{}) (*model.ChaosHubFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChaosHubFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOChaosHubStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v model.ChaosHubStatus) graphql.Marshaler {
	return ec._ChaosHubStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalOChaosHubStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHubStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChaosHubStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCreateEnvironmentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐCreateEnvironmentRequest(ctx context.Context, v interface{}) (model.CreateEnvironmentRequest, error) {
	return ec.unmarshalInputCreateEnvironmentRequest(ctx, v)
}

func (ec *executionContext) unmarshalOCreateEnvironmentRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐCreateEnvironmentRequest(ctx context.Context, v interface{}) (*model.CreateEnvironmentRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCreateEnvironmentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐCreateEnvironmentRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalODateRange2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐDateRange(ctx context.Context, v interface{}) (model.DateRange, error) {
	return ec.unmarshalInputDateRange(ctx, v)
}

func (ec *executionContext) unmarshalODateRange2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐDateRange(ctx context.Context, v interface{}) (*model.DateRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODateRange2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐDateRange(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEnvironment2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironment(ctx context.Context, sel ast.SelectionSet, v model.Environment) graphql.Marshaler {
	return ec._Environment(ctx, sel, &v)
}

func (ec *executionContext) marshalOEnvironment2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironment(ctx context.Context, sel ast.SelectionSet, v []*model.Environment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEnvironment2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOEnvironment2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironment(ctx context.Context, sel ast.SelectionSet, v *model.Environment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Environment(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEnvironmentFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentFilterInput(ctx context.Context, v interface{}) (model.EnvironmentFilterInput, error) {
	return ec.unmarshalInputEnvironmentFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOEnvironmentFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentFilterInput(ctx context.Context, v interface{}) (*model.EnvironmentFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEnvironmentFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOEnvironmentSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentSortInput(ctx context.Context, v interface{}) (model.EnvironmentSortInput, error) {
	return ec.unmarshalInputEnvironmentSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOEnvironmentSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentSortInput(ctx context.Context, v interface{}) (*model.EnvironmentSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEnvironmentSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOEnvironmentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx context.Context, v interface{}) (model.EnvironmentType, error) {
	var res model.EnvironmentType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOEnvironmentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx context.Context, sel ast.SelectionSet, v model.EnvironmentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOEnvironmentType2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx context.Context, v interface{}) ([]*model.EnvironmentType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.EnvironmentType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOEnvironmentType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEnvironmentType2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx context.Context, sel ast.SelectionSet, v []*model.EnvironmentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEnvironmentType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOEnvironmentType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx context.Context, v interface{}) (*model.EnvironmentType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEnvironmentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEnvironmentType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐEnvironmentType(ctx context.Context, sel ast.SelectionSet, v *model.EnvironmentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOExperiment2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiment(ctx context.Context, sel ast.SelectionSet, v model.Experiment) graphql.Marshaler {
	return ec._Experiment(ctx, sel, &v)
}

func (ec *executionContext) marshalOExperiment2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperiment(ctx context.Context, sel ast.SelectionSet, v *model.Experiment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Experiment(ctx, sel, v)
}

func (ec *executionContext) unmarshalOExperimentFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentFilterInput(ctx context.Context, v interface{}) (model.ExperimentFilterInput, error) {
	return ec.unmarshalInputExperimentFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentFilterInput(ctx context.Context, v interface{}) (*model.ExperimentFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOExperimentRun2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v model.ExperimentRun) graphql.Marshaler {
	return ec._ExperimentRun(ctx, sel, &v)
}

func (ec *executionContext) marshalOExperimentRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ExperimentRun(ctx, sel, v)
}

func (ec *executionContext) unmarshalOExperimentRunFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunFilterInput(ctx context.Context, v interface{}) (model.ExperimentRunFilterInput, error) {
	return ec.unmarshalInputExperimentRunFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentRunFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunFilterInput(ctx context.Context, v interface{}) (*model.ExperimentRunFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentRunFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOExperimentRunSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunSortInput(ctx context.Context, v interface{}) (model.ExperimentRunSortInput, error) {
	return ec.unmarshalInputExperimentRunSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentRunSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunSortInput(ctx context.Context, v interface{}) (*model.ExperimentRunSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentRunSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOExperimentRunStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunStatus(ctx context.Context, v interface{}) (model.ExperimentRunStatus, error) {
	var res model.ExperimentRunStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOExperimentRunStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunStatus(ctx context.Context, sel ast.SelectionSet, v model.ExperimentRunStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOExperimentRunStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunStatus(ctx context.Context, v interface{}) (*model.ExperimentRunStatus, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentRunStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunStatus(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOExperimentRunStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentRunStatus(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentRunStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOExperimentSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentSortInput(ctx context.Context, v interface{}) (model.ExperimentSortInput, error) {
	return ec.unmarshalInputExperimentSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentSortInput(ctx context.Context, v interface{}) (*model.ExperimentSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOExperimentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentType(ctx context.Context, v interface{}) (model.ExperimentType, error) {
	var res model.ExperimentType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOExperimentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentType(ctx context.Context, sel ast.SelectionSet, v model.ExperimentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOExperimentType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentType(ctx context.Context, v interface{}) (*model.ExperimentType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOExperimentType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐExperimentType(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOID2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOID2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOINFRA_SCOPE2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraScope(ctx context.Context, v interface{}) (model.InfraScope, error) {
	var res model.InfraScope
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOINFRA_SCOPE2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraScope(ctx context.Context, sel ast.SelectionSet, v model.InfraScope) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOINFRA_SCOPE2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraScope(ctx context.Context, v interface{}) (*model.InfraScope, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOINFRA_SCOPE2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraScope(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOINFRA_SCOPE2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraScope(ctx context.Context, sel ast.SelectionSet, v *model.InfraScope) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOImageRegistry2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistry(ctx context.Context, sel ast.SelectionSet, v model.ImageRegistry) graphql.Marshaler {
	return ec._ImageRegistry(ctx, sel, &v)
}

func (ec *executionContext) marshalOImageRegistry2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistry(ctx context.Context, sel ast.SelectionSet, v *model.ImageRegistry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImageRegistry(ctx, sel, v)
}

func (ec *executionContext) marshalOImageRegistryResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryResponseᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ImageRegistryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOInfra2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx context.Context, sel ast.SelectionSet, v model.Infra) graphql.Marshaler {
	return ec._Infra(ctx, sel, &v)
}

func (ec *executionContext) marshalOInfra2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfra(ctx context.Context, sel ast.SelectionSet, v *model.Infra) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Infra(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInfraFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraFilterInput(ctx context.Context, v interface{}) (model.InfraFilterInput, error) {
	return ec.unmarshalInputInfraFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOInfraFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraFilterInput(ctx context.Context, v interface{}) (*model.InfraFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInfraFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfraFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOInfrastructureType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx context.Context, v interface{}) (model.InfrastructureType, error) {
	var res model.InfrastructureType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOInfrastructureType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx context.Context, sel ast.SelectionSet, v model.InfrastructureType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOInfrastructureType2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx context.Context, v interface{}) ([]*model.InfrastructureType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.InfrastructureType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOInfrastructureType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInfrastructureType2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx context.Context, sel ast.SelectionSet, v []*model.InfrastructureType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInfrastructureType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOInfrastructureType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx context.Context, v interface{}) (*model.InfrastructureType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInfrastructureType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInfrastructureType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐInfrastructureType(ctx context.Context, sel ast.SelectionSet, v *model.InfrastructureType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOKubeGVRRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeGVRRequest(ctx context.Context, v interface{}) (model.KubeGVRRequest, error) {
	return ec.unmarshalInputKubeGVRRequest(ctx, v)
}

func (ec *executionContext) unmarshalOKubeGVRRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeGVRRequest(ctx context.Context, v interface{}) (*model.KubeGVRRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOKubeGVRRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeGVRRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOKubeObject2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObject(ctx context.Context, sel ast.SelectionSet, v model.KubeObject) graphql.Marshaler {
	return ec._KubeObject(ctx, sel, &v)
}

func (ec *executionContext) marshalOKubeObject2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐKubeObject(ctx context.Context, sel ast.SelectionSet, v *model.KubeObject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KubeObject(ctx, sel, v)
}

func (ec *executionContext) unmarshalOListChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListChaosHubRequest(ctx context.Context, v interface{}) (model.ListChaosHubRequest, error) {
	return ec.unmarshalInputListChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalOListChaosHubRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListChaosHubRequest(ctx context.Context, v interface{}) (*model.ListChaosHubRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOListChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListChaosHubRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOListEnvironmentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListEnvironmentRequest(ctx context.Context, v interface{}) (model.ListEnvironmentRequest, error) {
	return ec.unmarshalInputListEnvironmentRequest(ctx, v)
}

func (ec *executionContext) unmarshalOListEnvironmentRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListEnvironmentRequest(ctx context.Context, v interface{}) (*model.ListEnvironmentRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOListEnvironmentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListEnvironmentRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOListEnvironmentResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListEnvironmentResponse(ctx context.Context, sel ast.SelectionSet, v model.ListEnvironmentResponse) graphql.Marshaler {
	return ec._ListEnvironmentResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOListEnvironmentResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListEnvironmentResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListEnvironmentResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListEnvironmentResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOListInfraRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListInfraRequest(ctx context.Context, v interface{}) (model.ListInfraRequest, error) {
	return ec.unmarshalInputListInfraRequest(ctx, v)
}

func (ec *executionContext) unmarshalOListInfraRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListInfraRequest(ctx context.Context, v interface{}) (*model.ListInfraRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOListInfraRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐListInfraRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOObjectData2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐObjectData(ctx context.Context, sel ast.SelectionSet, v model.ObjectData) graphql.Marshaler {
	return ec._ObjectData(ctx, sel, &v)
}

func (ec *executionContext) marshalOObjectData2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐObjectData(ctx context.Context, sel ast.SelectionSet, v *model.ObjectData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObjectData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPagination2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPagination(ctx context.Context, v interface{}) (model.Pagination, error) {
	return ec.unmarshalInputPagination(ctx, v)
}

func (ec *executionContext) unmarshalOPagination2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPagination(ctx context.Context, v interface{}) (*model.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPagination2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐPagination(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalORecentExperimentRun2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRecentExperimentRun(ctx context.Context, sel ast.SelectionSet, v model.RecentExperimentRun) graphql.Marshaler {
	return ec._RecentExperimentRun(ctx, sel, &v)
}

func (ec *executionContext) marshalORecentExperimentRun2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRecentExperimentRun(ctx context.Context, sel ast.SelectionSet, v []*model.RecentExperimentRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORecentExperimentRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRecentExperimentRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalORecentExperimentRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐRecentExperimentRun(ctx context.Context, sel ast.SelectionSet, v *model.RecentExperimentRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RecentExperimentRun(ctx, sel, v)
}

func (ec *executionContext) marshalOResilienceScoreCategory2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐResilienceScoreCategory(ctx context.Context, sel ast.SelectionSet, v model.ResilienceScoreCategory) graphql.Marshaler {
	return ec._ResilienceScoreCategory(ctx, sel, &v)
}

func (ec *executionContext) marshalOResilienceScoreCategory2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐResilienceScoreCategory(ctx context.Context, sel ast.SelectionSet, v *model.ResilienceScoreCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResilienceScoreCategory(ctx, sel, v)
}

func (ec *executionContext) unmarshalOScheduleType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐScheduleType(ctx context.Context, v interface{}) (model.ScheduleType, error) {
	var res model.ScheduleType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOScheduleType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐScheduleType(ctx context.Context, sel ast.SelectionSet, v model.ScheduleType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOScheduleType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐScheduleType(ctx context.Context, v interface{}) (*model.ScheduleType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOScheduleType2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐScheduleType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOScheduleType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐScheduleType(ctx context.Context, sel ast.SelectionSet, v *model.ScheduleType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOToleration2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐToleration(ctx context.Context, v interface{}) (model.Toleration, error) {
	return ec.unmarshalInputToleration(ctx, v)
}

func (ec *executionContext) unmarshalOToleration2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐToleration(ctx context.Context, v interface{}) ([]*model.Toleration, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Toleration, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOToleration2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐToleration(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOToleration2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐToleration(ctx context.Context, v interface{}) (*model.Toleration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOToleration2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐToleration(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUpdateEnvironmentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUpdateEnvironmentRequest(ctx context.Context, v interface{}) (model.UpdateEnvironmentRequest, error) {
	return ec.unmarshalInputUpdateEnvironmentRequest(ctx, v)
}

func (ec *executionContext) unmarshalOUpdateEnvironmentRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUpdateEnvironmentRequest(ctx context.Context, v interface{}) (*model.UpdateEnvironmentRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUpdateEnvironmentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUpdateEnvironmentRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUserDetails2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx context.Context, sel ast.SelectionSet, v model.UserDetails) graphql.Marshaler {
	return ec._UserDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalOUserDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐUserDetails(ctx context.Context, sel ast.SelectionSet, v *model.UserDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkload2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWorkload(ctx context.Context, v interface{}) (model.Workload, error) {
	return ec.unmarshalInputWorkload(ctx, v)
}

func (ec *executionContext) unmarshalOWorkload2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWorkload(ctx context.Context, v interface{}) ([]*model.Workload, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Workload, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOWorkload2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWorkload(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWorkload2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWorkload(ctx context.Context, v interface{}) (*model.Workload, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkload2githubᚗcomᚋlitmuschaosᚋlitmusᚋchaoscenterᚋgraphqlᚋserverᚋgraphᚋmodelᚐWorkload(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
